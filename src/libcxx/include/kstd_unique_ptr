/**
 * @copyright Copyright The SimpleKernel Contributors
 * @brief Move-only owning smart pointer for kstd namespace.
 *
 * This is the canonical unique_ptr implementation for the kstd namespace.
 * moved to the kstd namespace. unique_ptr does not use ETL pools —
 * it's a standard smart pointer wrapping heap allocation.
 *
 * @note kstd::unique_ptr requires heap allocation via ::operator new/delete.
 * It MUST only be used after MemoryInit() has been called during kernel boot.
 */

#ifndef SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_KSTD_UNIQUE_PTR_
#define SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_KSTD_UNIQUE_PTR_

#include <cstddef>

namespace kstd {

/// @brief Default deleter for single objects (calls `delete`).
template <typename T>
struct default_delete {
  constexpr default_delete() noexcept = default;
  auto operator()(T* ptr) const noexcept -> void { delete ptr; }
};

/// @brief Default deleter for arrays (calls `delete[]`).
template <typename T>
struct default_delete<T[]> {
  constexpr default_delete() noexcept = default;
  auto operator()(T* ptr) const noexcept -> void { delete[] ptr; }
};

/// @brief Move-only owning smart pointer for single objects.
///
/// Holds exclusive ownership of a dynamically allocated object and deletes it
/// when the unique_ptr is destroyed or reset.
///
/// @note Thread safety: unique_ptr itself is NOT thread-safe. Callers must
///       synchronize concurrent access to the same unique_ptr instance.
///
/// @pre  MemoryInit() must have been called before constructing any unique_ptr.
/// @tparam T      Type of the managed object.
/// @tparam Deleter Callable type used to destroy the managed object.
template <typename T, typename Deleter = default_delete<T>>
class unique_ptr {
 public:
  /// @brief Default constructor — null state.
  constexpr unique_ptr() noexcept : ptr_(nullptr), deleter_() {}

  /// @brief Construct from nullptr literal.
  constexpr unique_ptr(decltype(nullptr)) noexcept  // NOLINT
      : ptr_(nullptr), deleter_() {}

  /// @brief Construct from raw pointer, taking ownership.
  ///
  /// @pre  ptr was allocated with ::operator new (or nullptr).
  /// @post get() == ptr
  explicit unique_ptr(T* ptr) noexcept : ptr_(ptr), deleter_() {}

  /// @brief Construct from raw pointer with custom deleter.
  unique_ptr(T* ptr, const Deleter& d) noexcept : ptr_(ptr), deleter_(d) {}

  /// @brief Move constructor — transfers ownership, source becomes null.
  unique_ptr(unique_ptr&& other) noexcept
      : ptr_(other.ptr_), deleter_(static_cast<Deleter&&>(other.deleter_)) {
    other.ptr_ = nullptr;
  }

  /// @brief No copy construction.
  unique_ptr(const unique_ptr&) = delete;

  /// @brief Destructor — deletes managed object if non-null.
  ~unique_ptr() {
    if (ptr_ != nullptr) {
      deleter_(ptr_);
    }
  }

  /// @brief Move assignment — releases current, transfers other's ownership.
  auto operator=(unique_ptr&& other) noexcept -> unique_ptr& {
    if (this != &other) {
      reset();
      ptr_ = other.ptr_;
      deleter_ = static_cast<Deleter&&>(other.deleter_);
      other.ptr_ = nullptr;
    }
    return *this;
  }

  /// @brief No copy assignment.
  auto operator=(const unique_ptr&) -> unique_ptr& = delete;

  /// @brief Assign nullptr — equivalent to reset().
  auto operator=(decltype(nullptr)) noexcept -> unique_ptr& {
    reset();
    return *this;
  }

  /// @brief Release ownership and return the raw pointer.
  ///
  /// @post get() == nullptr. Caller is responsible for deleting the object.
  [[nodiscard]] auto release() noexcept -> T* {
    T* tmp = ptr_;
    ptr_ = nullptr;
    return tmp;
  }

  /// @brief Replace managed object (delete old, take ownership of new).
  auto reset(T* ptr = nullptr) noexcept -> void {
    T* old = ptr_;
    ptr_ = ptr;
    if (old != nullptr) {
      deleter_(old);
    }
  }

  /// @brief Swap two unique_ptrs.
  auto swap(unique_ptr& other) noexcept -> void {
    T* tmp_ptr = ptr_;
    ptr_ = other.ptr_;
    other.ptr_ = tmp_ptr;

    Deleter tmp_del = static_cast<Deleter&&>(deleter_);
    deleter_ = static_cast<Deleter&&>(other.deleter_);
    other.deleter_ = static_cast<Deleter&&>(tmp_del);
  }

  /// @brief Return the stored raw pointer (nullptr if empty).
  [[nodiscard]] auto get() const noexcept -> T* { return ptr_; }

  /// @brief Return reference to the deleter.
  [[nodiscard]] auto get_deleter() noexcept -> Deleter& { return deleter_; }

  /// @brief Return const reference to the deleter.
  [[nodiscard]] auto get_deleter() const noexcept -> const Deleter& {
    return deleter_;
  }

  /// @brief Return true if this unique_ptr owns a non-null object.
  [[nodiscard]] explicit operator bool() const noexcept {
    return ptr_ != nullptr;
  }

  /// @brief Dereference the managed object.
  /// @pre  get() != nullptr
  [[nodiscard]] auto operator*() const noexcept -> T& { return *ptr_; }

  /// @brief Member access on the managed object.
  /// @pre  get() != nullptr
  [[nodiscard]] auto operator->() const noexcept -> T* { return ptr_; }

 private:
  T* ptr_;
  Deleter deleter_;
};

/// @brief Move-only owning smart pointer for dynamically allocated arrays.
///
/// Same as the primary template but provides operator[] instead of
/// operator* and operator->. Uses delete[] by default.
///
/// @pre  MemoryInit() must have been called before constructing any unique_ptr.
/// @tparam T      Element type of the managed array.
/// @tparam Deleter Callable type used to destroy the managed array.
template <typename T, typename Deleter>
class unique_ptr<T[], Deleter> {
 public:
  constexpr unique_ptr() noexcept : ptr_(nullptr), deleter_() {}

  constexpr unique_ptr(decltype(nullptr)) noexcept  // NOLINT
      : ptr_(nullptr), deleter_() {}

  explicit unique_ptr(T* ptr) noexcept : ptr_(ptr), deleter_() {}

  unique_ptr(T* ptr, const Deleter& d) noexcept : ptr_(ptr), deleter_(d) {}

  unique_ptr(unique_ptr&& other) noexcept
      : ptr_(other.ptr_), deleter_(static_cast<Deleter&&>(other.deleter_)) {
    other.ptr_ = nullptr;
  }

  unique_ptr(const unique_ptr&) = delete;

  ~unique_ptr() {
    if (ptr_ != nullptr) {
      deleter_(ptr_);
    }
  }

  auto operator=(unique_ptr&& other) noexcept -> unique_ptr& {
    if (this != &other) {
      reset();
      ptr_ = other.ptr_;
      deleter_ = static_cast<Deleter&&>(other.deleter_);
      other.ptr_ = nullptr;
    }
    return *this;
  }

  auto operator=(const unique_ptr&) -> unique_ptr& = delete;

  auto operator=(decltype(nullptr)) noexcept -> unique_ptr& {
    reset();
    return *this;
  }

  [[nodiscard]] auto release() noexcept -> T* {
    T* tmp = ptr_;
    ptr_ = nullptr;
    return tmp;
  }

  auto reset(T* ptr = nullptr) noexcept -> void {
    T* old = ptr_;
    ptr_ = ptr;
    if (old != nullptr) {
      deleter_(old);
    }
  }

  auto swap(unique_ptr& other) noexcept -> void {
    T* tmp_ptr = ptr_;
    ptr_ = other.ptr_;
    other.ptr_ = tmp_ptr;

    Deleter tmp_del = static_cast<Deleter&&>(deleter_);
    deleter_ = static_cast<Deleter&&>(other.deleter_);
    other.deleter_ = static_cast<Deleter&&>(tmp_del);
  }

  [[nodiscard]] auto get() const noexcept -> T* { return ptr_; }

  [[nodiscard]] auto get_deleter() noexcept -> Deleter& { return deleter_; }

  [[nodiscard]] auto get_deleter() const noexcept -> const Deleter& {
    return deleter_;
  }

  [[nodiscard]] explicit operator bool() const noexcept {
    return ptr_ != nullptr;
  }

  /// @brief Array subscript access.
  /// @pre  get() != nullptr && idx is within bounds
  [[nodiscard]] auto operator[](size_t idx) const -> T& { return ptr_[idx]; }

 private:
  T* ptr_;
  Deleter deleter_;
};

/// @brief Swap two unique_ptrs (non-member overload).
template <typename T, typename D>
auto swap(unique_ptr<T, D>& a, unique_ptr<T, D>& b) noexcept -> void {
  a.swap(b);
}

/// @brief Equality comparison.
template <typename T1, typename D1, typename T2, typename D2>
auto operator==(const unique_ptr<T1, D1>& a, const unique_ptr<T2, D2>& b)
    -> bool {
  return a.get() == b.get();
}

/// @brief Compare with nullptr.
template <typename T, typename D>
auto operator==(const unique_ptr<T, D>& p, decltype(nullptr)) -> bool {
  return p.get() == nullptr;
}

/// @brief Compare nullptr with unique_ptr.
template <typename T, typename D>
auto operator==(decltype(nullptr), const unique_ptr<T, D>& p) -> bool {
  return p.get() == nullptr;
}

/// @brief Inequality comparison.
template <typename T1, typename D1, typename T2, typename D2>
auto operator!=(const unique_ptr<T1, D1>& a, const unique_ptr<T2, D2>& b)
    -> bool {
  return !(a == b);
}

/// @brief Inequality with nullptr.
template <typename T, typename D>
auto operator!=(const unique_ptr<T, D>& p, decltype(nullptr)) -> bool {
  return !(p == nullptr);
}

/// @brief Inequality nullptr with unique_ptr.
template <typename T, typename D>
auto operator!=(decltype(nullptr), const unique_ptr<T, D>& p) -> bool {
  return !(p == nullptr);
}

/// @brief Create a unique_ptr, constructing T in-place from args.
///
/// Equivalent to unique_ptr<T>(new T(args...)).
///
/// @pre  MemoryInit() must have been called.
template <typename T, typename... Args>
auto make_unique(Args&&... args) -> unique_ptr<T> {
  return unique_ptr<T>(new T(static_cast<Args&&>(args)...));
}

}  // namespace kstd

#endif  // SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_KSTD_UNIQUE_PTR_
