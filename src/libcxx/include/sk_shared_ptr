/**
 * @copyright Copyright The SimpleKernel Contributors
 */

#ifndef SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_SHARED_PTR_
#define SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_SHARED_PTR_

// @note sk_std::shared_ptr requires heap allocation via ::operator new/delete.
// It MUST only be used after MemoryInit() has been called during kernel boot.
// Using shared_ptr before MemoryInit() will result in undefined behavior or
// a kernel crash.

#include <atomic>
#include <cstddef>
#include <new>

namespace sk_std {

/// @brief Internal reference-count control block for shared_ptr.
///
/// Holds the managed object pointer and an atomic reference count.
/// Deleted automatically when ref_count drops to zero.
template <typename T>
struct control_block {
  T* ptr;
  std::atomic<size_t> ref_count;

  explicit control_block(T* p) : ptr(p), ref_count(1) {}

  /// @brief Increment reference count (relaxed ordering — no synchronization
  /// needed on increment).
  auto add_ref() -> void {
    ref_count.fetch_add(1, std::memory_order_relaxed);
  }

  /// @brief Decrement reference count and destroy if last owner.
  ///
  /// Uses acq_rel ordering so that the destroying thread sees all writes done
  /// by other threads before they released their last reference.
  auto release() -> void {
    if (ref_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {
      delete ptr;
      delete this;
    }
  }
};

/// @brief Non-intrusive reference-counted smart pointer.
///
/// Provides shared ownership of a heap-allocated object. The object is
/// destroyed when the last shared_ptr owning it is destroyed or reset.
///
/// @note Thread-safe for reference count operations (atomic). The managed
///       object itself is NOT protected by shared_ptr; callers are responsible
///       for synchronizing access to the managed object.
///
/// @pre  MemoryInit() must have been called before constructing any shared_ptr.
/// @tparam T Type of the managed object.
template <typename T>
class shared_ptr {
 public:
  // ── Constructors ─────────────────────────────────────────────────────────

  /// @brief Default constructor — null state, use_count() == 0.
  shared_ptr() noexcept : ctrl_(nullptr) {}

  /// @brief Construct from raw pointer, taking ownership.
  ///
  /// @pre  ptr was allocated with ::operator new (or nullptr).
  /// @post use_count() == 1 if ptr != nullptr, else 0.
  explicit shared_ptr(T* ptr) : ctrl_(nullptr) {
    if (ptr != nullptr) {
      ctrl_ = new control_block<T>(ptr);
    }
  }

  /// @brief Copy constructor — shares ownership, increments ref count.
  shared_ptr(const shared_ptr& other) noexcept : ctrl_(other.ctrl_) {
    if (ctrl_ != nullptr) {
      ctrl_->add_ref();
    }
  }

  /// @brief Move constructor — transfers ownership, source becomes null.
  shared_ptr(shared_ptr&& other) noexcept : ctrl_(other.ctrl_) {
    other.ctrl_ = nullptr;
  }

  /// @brief Destructor — releases ownership, deletes if last.
  ~shared_ptr() {
    if (ctrl_ != nullptr) {
      ctrl_->release();
    }
  }

  // ── Assignment ───────────────────────────────────────────────────────────

  /// @brief Copy assignment — releases current, shares other's ownership.
  auto operator=(const shared_ptr& other) noexcept -> shared_ptr& {
    if (this != &other) {
      // Acquire new reference before releasing old to handle self-assignment
      // through aliases and to keep things safe.
      auto* new_ctrl = other.ctrl_;
      if (new_ctrl != nullptr) {
        new_ctrl->add_ref();
      }
      if (ctrl_ != nullptr) {
        ctrl_->release();
      }
      ctrl_ = new_ctrl;
    }
    return *this;
  }

  /// @brief Move assignment — releases current, transfers other's ownership.
  auto operator=(shared_ptr&& other) noexcept -> shared_ptr& {
    if (this != &other) {
      if (ctrl_ != nullptr) {
        ctrl_->release();
      }
      ctrl_ = other.ctrl_;
      other.ctrl_ = nullptr;
    }
    return *this;
  }

  // ── Modifiers ────────────────────────────────────────────────────────────

  /// @brief Release ownership and become null.
  auto reset() noexcept -> void {
    if (ctrl_ != nullptr) {
      ctrl_->release();
      ctrl_ = nullptr;
    }
  }

  /// @brief Release current ownership and take ownership of ptr.
  ///
  /// @pre  ptr was allocated with ::operator new (or nullptr).
  auto reset(T* ptr) -> void {
    if (ctrl_ != nullptr) {
      ctrl_->release();
      ctrl_ = nullptr;
    }
    if (ptr != nullptr) {
      ctrl_ = new control_block<T>(ptr);
    }
  }

  /// @brief Swap two shared_ptrs.
  auto swap(shared_ptr& other) noexcept -> void {
    auto* tmp = ctrl_;
    ctrl_ = other.ctrl_;
    other.ctrl_ = tmp;
  }

  // ── Observers ────────────────────────────────────────────────────────────

  /// @brief Return the stored raw pointer (nullptr if empty).
  [[nodiscard]] auto get() const noexcept -> T* {
    return ctrl_ != nullptr ? ctrl_->ptr : nullptr;
  }

  /// @brief Dereference the managed object.
  /// @pre  get() != nullptr
  [[nodiscard]] auto operator*() const noexcept -> T& { return *ctrl_->ptr; }

  /// @brief Member access on the managed object.
  /// @pre  get() != nullptr
  [[nodiscard]] auto operator->() const noexcept -> T* { return ctrl_->ptr; }

  /// @brief Return current reference count (0 if null).
  [[nodiscard]] auto use_count() const noexcept -> size_t {
    return ctrl_ != nullptr
               ? ctrl_->ref_count.load(std::memory_order_relaxed)
               : 0;
  }

  /// @brief Return true if this shared_ptr owns a non-null object.
  [[nodiscard]] explicit operator bool() const noexcept {
    return ctrl_ != nullptr;
  }

 private:
  control_block<T>* ctrl_;
};

// ── Non-member functions ──────────────────────────────────────────────────

/// @brief Swap two shared_ptrs (non-member overload).
template <typename T>
auto swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept -> void {
  a.swap(b);
}

/// @brief Create a shared_ptr, constructing T in-place from args.
///
/// Equivalent to shared_ptr<T>(new T(args...)).  The single-allocation
/// optimisation is deferred until weak_ptr support is added.
///
/// @pre  MemoryInit() must have been called.
template <typename T, typename... Args>
auto make_shared(Args&&... args) -> shared_ptr<T> {
  return shared_ptr<T>(new T(static_cast<Args&&>(args)...));
}

}  // namespace sk_std

#endif /* SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_SHARED_PTR_ */
