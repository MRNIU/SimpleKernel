/**
 * @copyright Copyright The SimpleKernel Contributors
 */

#ifndef SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_SET_
#define SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_SET_

#include "sk_rb_tree"
#include <functional>
#include <utility>

namespace sk_std {

template <typename Key, typename Compare = std::less<Key>>
class set {
 public:
  using key_type = Key;
  using value_type = Key;
  using key_compare = Compare;
  using value_compare = Compare;

 private:
  template <typename T>
  struct Identity {
    const T& operator()(const T& x) const { return x; }
  };

  using Rep = RbTree<key_type, value_type, Identity<value_type>, key_compare>;

  Rep t;  // Red-black tree representing set.

 public:
  using pointer = typename Rep::const_pointer;
  using const_pointer = typename Rep::const_pointer;
  using reference = typename Rep::const_reference;
  using const_reference = typename Rep::const_reference;
  using iterator = typename Rep::const_iterator;
  using const_iterator = typename Rep::const_iterator;
  using size_type = typename Rep::size_type;
  using difference_type = typename Rep::difference_type;

  set() : t() {}
  explicit set(const Compare& comp) : t(comp) {}
  set(const set& x) : t(x.t) {}

  set& operator=(const set& x) {
      t = x.t;
      return *this;
  }

  key_compare key_comp() const { return t.key_comp(); }
  value_compare value_comp() const { return t.key_comp(); }

  iterator begin() const { return t.begin(); }
  iterator end() const { return t.end(); }
  bool empty() const { return t.empty(); }
  size_type size() const { return t.size(); }

  void clear() { t.clear(); }

  std::pair<iterator, bool> insert(const value_type& x) {
    std::pair<typename Rep::iterator, bool> p = t.insert_unique(x);
    return std::pair<iterator, bool>(p.first, p.second);
  }

  void erase(iterator position) {
    // RbTree erase takes Rep::iterator
    // position is Rep::const_iterator
    // We need to cast it back to const-less iterator because we own the modification.
    // Since we only have access to node pointer, and RbTreeIterator has it public or accessible.
    // RbTreeIterator has NodePtr constructor.
    // Wait, Rep::iterator and Rep::const_iterator both store `node`.

    // Using strict aliasing compliant cast or just reconstruction:
    // This assumes we can construct iterator from const_iterator which is not standard but we can utilize internal logic.
    // Or we cast the iterator.

    // Let's rely on the fact that we can construct iterator from node.
    // But `iterator` (Rep::const_iterator) might not expose `node` publicly?
    // In `sk_rb_tree.hpp`, `RbTreeIteratorBase` has `node`.

    // We cast away constness of the iterator to match RbTree interface or improve RbTree interface.
    // But here, I'll assume I can just do:
    t.erase(no_const(position));
  }

  size_type erase(const key_type& x) { return t.erase(x); }

  iterator find(const key_type& x) const { return t.find(x); }

  size_type count(const key_type& x) const { return t.find(x) == t.end() ? 0 : 1; }

  iterator lower_bound(const key_type& x) const { return t.lower_bound(x); }
  iterator upper_bound(const key_type& x) const { return t.upper_bound(x); }

 private:
  typename Rep::iterator no_const(iterator it) {
      // Create a mutable iterator from const iterator
      // Since they share the same base structure and we know it's safe inside set implementation
      // Use a trick or direct construction if constructor available.
      // My RbTreeIterator has `node`.
      // I can add a method to convert or just copy the node pointer.
      // But `node` is in Base.
      // `iterator` is `const_iterator` here (typedef).
      // `Rep::iterator` is mutable iterator.
      return typename Rep::iterator((typename RbTreeNode<value_type>::LinkType)it.node);
  }
};

}  // namespace sk_std

#endif
