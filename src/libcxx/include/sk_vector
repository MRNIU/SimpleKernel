/**
 * @copyright Copyright The SimpleKernel Contributors
 */

#ifndef SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_VECTOR_
#define SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_VECTOR_

#include <cstddef>
#include <new>

namespace sk_std {

template <typename T>
class vector {
 public:
  using value_type = T;
  using pointer = T*;
  using const_pointer = const T*;
  using reference = T&;
  using const_reference = const T&;
  using size_type = size_t;
  using iterator = T*;
  using const_iterator = const T*;

  vector() : data_(nullptr), size_(0), capacity_(0) {}

  explicit vector(size_type count) : data_(nullptr), size_(0), capacity_(0) {
    resize(count);
  }

  vector(size_type count, const T& value)
      : data_(nullptr), size_(0), capacity_(0) {
    resize(count, value);
  }

  vector(const vector& other) : data_(nullptr), size_(0), capacity_(0) {
    reserve(other.size_);
    for (size_type i = 0; i < other.size_; ++i) {
      new (data_ + i) T(other.data_[i]);
    }
    size_ = other.size_;
  }

  vector(vector&& other) noexcept
      : data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
    other.data_ = nullptr;
    other.size_ = 0;
    other.capacity_ = 0;
  }

  ~vector() {
    clear();
    if (data_) {
      ::operator delete(data_);
    }
  }

  vector& operator=(const vector& other) {
    if (this != &other) {
      clear();
      reserve(other.size_);
      for (size_type i = 0; i < other.size_; ++i) {
        new (data_ + i) T(other.data_[i]);
      }
      size_ = other.size_;
    }
    return *this;
  }

  vector& operator=(vector&& other) noexcept {
    if (this != &other) {
      clear();
      if (data_) {
        ::operator delete(data_);
      }
      data_ = other.data_;
      size_ = other.size_;
      capacity_ = other.capacity_;
      other.data_ = nullptr;
      other.size_ = 0;
      other.capacity_ = 0;
    }
    return *this;
  }

  void push_back(const T& value) {
    if (size_ == capacity_) {
      reserve(capacity_ == 0 ? 1 : capacity_ * 2);
    }
    new (data_ + size_) T(value);
    ++size_;
  }

  void pop_back() {
    if (size_ > 0) {
      --size_;
      data_[size_].~T();
    }
  }

  reference operator[](size_type index) { return data_[index]; }

  const_reference operator[](size_type index) const { return data_[index]; }

  reference at(size_type index) { return data_[index]; }

  const_reference at(size_type index) const { return data_[index]; }

  reference front() { return data_[0]; }
  const_reference front() const { return data_[0]; }
  reference back() { return data_[size_ - 1]; }
  const_reference back() const { return data_[size_ - 1]; }

  size_type size() const { return size_; }
  size_type capacity() const { return capacity_; }
  bool empty() const { return size_ == 0; }

  void clear() {
    for (size_type i = 0; i < size_; ++i) {
      data_[i].~T();
    }
    size_ = 0;
  }

  void reserve(size_type new_cap) {
    if (new_cap > capacity_) {
      T* new_data = static_cast<T*>(::operator new(new_cap * sizeof(T)));
      for (size_type i = 0; i < size_; ++i) {
        new (new_data + i) T(static_cast<T&&>(data_[i]));
        data_[i].~T();
      }
      if (data_) {
        ::operator delete(data_);
      }
      data_ = new_data;
      capacity_ = new_cap;
    }
  }

  void resize(size_type count) {
    if (count < size_) {
      for (size_type i = count; i < size_; ++i) {
        data_[i].~T();
      }
      size_ = count;
    } else if (count > size_) {
      reserve(count);
      for (size_type i = size_; i < count; ++i) {
        new (data_ + i) T();
      }
      size_ = count;
    }
  }

  void resize(size_type count, const T& value) {
    if (count < size_) {
      for (size_type i = count; i < size_; ++i) {
        data_[i].~T();
      }
      size_ = count;
    } else if (count > size_) {
      reserve(count);
      for (size_type i = size_; i < count; ++i) {
        new (data_ + i) T(value);
      }
      size_ = count;
    }
  }

  iterator begin() { return data_; }
  iterator end() { return data_ + size_; }
  const_iterator begin() const { return data_; }
  const_iterator end() const { return data_ + size_; }
  const_iterator cbegin() const { return data_; }
  const_iterator cend() const { return data_ + size_; }

 private:
  T* data_;
  size_type size_;
  size_type capacity_;
};

}  // namespace sk_std

#endif  // SIMPLEKERNEL_SRC_LIBCXX_INCLUDE_SK_VECTOR_
