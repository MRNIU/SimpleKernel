# SimpleKernel 系统调用

## IA32

TODO

## RISCV

中断更新
```c++
/**
 * @brief 中断处理函数
 * @param  _scause         原因
 * @param  _sepc           值
 * @param  _stval          值
 * @param  _scause         值
 * @param  _all_regs       保存在栈上的所有寄存器，实际上是 sp
 * @param  _sie            值
 * @param  _sstatus        值
 * @param  _sscratch       值
 */
extern "C" void trap_handler(uintptr_t _sepc, uintptr_t _stval,
                             uintptr_t _scause, CPU::all_regs_t *_all_regs,
                             uintptr_t _sie, CPU::sstatus_t _sstatus,
                             CPU::satp_t _satp, uintptr_t _sscratch) {
    if (_scause & CPU::CAUSE_INTR_MASK) {
        // 中断
        // 跳转到对应的处理函数
        INTR::get_instance().do_interrupt(_scause & CPU::CAUSE_CODE_MASK, 0,
                                          nullptr);
        // 如果是时钟中断
        if ((_scause & CPU::CAUSE_CODE_MASK) == CPU::INTR_TIMER_S) {
            // 切换到内核线程
            switch_context(
                &core_t::get_curr_task()->context,
                &core_t::cores[CPU::get_curr_core_id()].sched_task->context);
        }
    }
    else {
        // 异常
        // 跳转到对应的处理函数
        // 跳转到对应的处理函数
        if (((_scause & CPU::CAUSE_CODE_MASK) == CPU::EXCP_ECALL_U) ||
            ((_scause & CPU::CAUSE_CODE_MASK) == CPU::EXCP_BREAKPOINT)) {
            char *argv = (char *)kmalloc(sizeof(CPU::all_regs_t));
            memcpy(argv, _all_regs, sizeof(CPU::all_regs_t));
            _all_regs->sepc += CPU::EXCP_ECALL_INSTRUCTION_LENGTH;
            INTR::get_instance().do_excp(_scause & CPU::CAUSE_CODE_MASK, 1,
                                         &argv);
        }
        else {
            INTR::get_instance().do_excp(_scause & CPU::CAUSE_CODE_MASK, 0,
                                         nullptr);
        }
    }
    return;
}
```

系统调用实现
```c++
int32_t SYSCALL::syscall(uint8_t _sysno, ...) {
    va_list ap;
    va_start(ap, _sysno);
    uintptr_t a[MAX_ARGS];
    for (size_t i = 0; i < MAX_ARGS; i++) {
        a[i] = va_arg(ap, uintptr_t);
    }
    va_end(ap);
    register uintptr_t a0 asm("a0") = _sysno;
    register uintptr_t a1 asm("a1") = a[0];
    register uintptr_t a2 asm("a2") = a[1];
    register uintptr_t a3 asm("a3") = a[2];
    register uintptr_t a4 asm("a4") = a[3];
    register uintptr_t a5 asm("a5") = a[4];
    register uintptr_t a6 asm("a6") = a[5];
    register uintptr_t a7 asm("a7") = a[6];
    asm volatile("ecall"
                 : "+r"(a0)
                 : "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5), "r"(a6), "r"(a7)
                 : "memory");
    return a0;
}
```


更多细节请查看注释。

- 相关代码

    ./src/include/syscall.h

    ./src/kernel/syscall.cpp

## 相关文档

TODO
