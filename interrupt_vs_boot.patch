diff --git a/README.md b/README.md
index 4995377d..355cf9ad 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 [![codecov](https://codecov.io/gh/Simple-XX/SimpleKernel/graph/badge.svg?token=J7NKK3SBNJ)](https://codecov.io/gh/Simple-XX/SimpleKernel)
 ![workflow](https://github.com/Simple-XX/SimpleKernel/actions/workflows/workflow.yml/badge.svg)
 ![commit-activity](https://img.shields.io/github/commit-activity/t/Simple-XX/SimpleKernel)
-![last-commit-boot](https://img.shields.io/github/last-commit/Simple-XX/SimpleKernel/boot)
+![last-commit-interrupt](https://img.shields.io/github/last-commit/Simple-XX/SimpleKernel/interrupt)
 ![MIT License](https://img.shields.io/github/license/mashape/apistatus.svg)
 [![LICENSE](https://img.shields.io/badge/license-Anti%20996-blue.svg)](https://github.com/996icu/996.ICU/blob/master/LICENSE)
 [![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu)
@@ -10,9 +10,7 @@
 
 # SimpleKernel
 
-**一个现代的多架构内核操作系统，支持 x86_64、RISC-V 和 AArch64 架构**
-
-boot branch
+interrupt branch
 
 ## 关键词
 
@@ -65,150 +63,78 @@ make run
 
 本分支是 SimpleKernel 的首个分支。在本分支中，完成了构建系统的基础搭建、基本的文档部署与自动化测试，当然还有最重要的，有基于 u-boot 引导的 x86_64 内核与由 opensbi 启动的 riscv64 内核，可以在 qemu 上运行，并实现了简单的屏幕输出。
 
-||x86_64|riscv64|aarch64|
-| :-----------------------: | :-------------------------------: | :---------------------------------------------: | :-------------------: |
-|引导|u-boot|u-boot+opensbi|u-boot+atf+optee|
-|基本输出|通过 serial 实现|通过 opensbi 提供的 ecall 实现|通过 serial 实现|
-|硬件资源探测|由 u-boot 传递|由 u-boot 传递的 dtb|由 u-boot+atf 传递的 dtb|
+- riscv64
 
-- 构建系统
+    1. 对 CSR 寄存器的抽象
+    2. 寄存器状态打印
+    3. 基于 Direct 的中断处理
+    4. 中断注册函数
+    5. 时钟中断
 
-  参考 [MRNIU/cmake-kernel](https://github.com/MRNIU/cmake-kernel) 的构建系统，详细解释见 [doc/build_system.md](./doc/build_system.md)
+- aarch64
 
-- libc 支持
+    1. 中断注册函数
+    2. 时钟中断
+    3. uart 中断
+    4. gicv3 驱动
 
-  |     函数/变量名      |                       用途                       |      |
-  | :------------------: | :----------------------------------------------: | :--: |
-  | `__stack_chk_guard`  |                      栈保护                      |      |
-  | `__stack_chk_fail()` |               栈保护检查失败后调用               |      |
-  |      `memcpy()`      |                    复制内存块                    |      |
-  |     `memmove()`      |          复制内存块，可以处理重叠区域。          |      |
-  |      `memset()`      |                    设置内存块                    |      |
-  |      `memcmp()`      |                    比较内存块                    |      |
-  |      `memchr()`      |                在内存块中查找字符                |      |
-  |      `strcpy()`      |                    复制字符串                    |      |
-  |     `strncpy()`      |               复制指定长度的字符串               |      |
-  |      `strcat()`      |                    连接字符串                    |      |
-  |      `strcmp()`      |                    比较字符串                    |      |
-  |     `strncmp()`      |               比较指定长度的字符串               |      |
-  |      `strlen()`      |                  获取字符串长度                  |      |
-  |     `strnlen()`      |                获取指定字符串长度                |      |
-  |      `strchr()`      |           查找字符在字符串中的首次出现           |      |
-  |     `strrchr()`      |         反向查找字符在字符串中的首次出现         |      |
-  |     `strtoull()`     |      将字符串按指定进制转换为无符号长长整数      |      |
-  |     `strtoul()`      |       将字符串按指定进制转换为无符号长整数       |      |
-  |     `strtoll()`      |         将字符串按指定进制转换为长长整数         |      |
-  |      `strtol()`      |          将字符串按指定进制转换为长整数          |      |
-  |      `atoll()`       |              将字符串转换为长长整数              |      |
-  |       `atol()`       |               将字符串转换为长整数               |      |
-  |       `atoi()`       |                将字符串转换为整数                |      |
-  |     `isalnum()`      |             检查字符是否为字母或数字             |      |
-  |     `isalpha()`      |                检查字符是否为字母                |      |
-  |     `isblank()`      |      检查字符是否为空白字符（空格或制表符）      |      |
-  |     `iscntrl()`      |              检查字符是否为控制字符              |      |
-  |     `isdigit()`      |         检查字符是否为十进制数字（0-9）          |      |
-  |     `isgraph()`      |      检查字符是否为可打印字符（不包括空格）      |      |
-  |     `islower()`      |              检查字符是否为小写字母              |      |
-  |     `isprint()`      |       检查字符是否为可打印字符（包括空格）       |      |
-  |     `ispunct()`      |              检查字符是否为标点符号              |      |
-  |     `isspace()`      | 检查字符是否为空白字符（空格、制表符、换行符等） |      |
-  |     `isupper()`      |              检查字符是否为大写字母              |      |
-  |     `isxdigit()`     |   检查字符是否为十六进制数字（0-9、a-f、A-F）    |      |
-  |     `tolower()`      |                 将字符转换为小写                 |      |
-  |     `toupper()`      |                 将字符转换为大写                 |      |
+- X86_64
 
-- libc++ 支持
+    1. cpu 抽象
+    2. 8259A pic 控制器抽象
+    3. 8253/8254 timer 控制器抽象
+    4. gdt 初始化
+    5. 中断处理流程
+    6. 中断注册函数
+    7. 时钟中断
 
-    |       函数/变量名       |                 用途                 |      |
-    | :---------------------: | :----------------------------------: | :--: |
-    |    `__cxa_atexit()`     |             注册析构函数             |      |
-    |   `__cxa_finalize()`    |             调用析构函数             |      |
-    | `__cxa_guard_acquire()` |         静态局部变量初始化锁         |      |
-    | `__cxa_guard_release()` |        静态局部变量初始化完成        |      |
-    |  `__cxa_guard_abort()`  |        静态局部变量初始化出错        |      |
-    |    `__cxa_rethrow()`    |         用于简单处理 `throw`         |      |
-    |    `operator new()`     | 运算符重载，空实现，用于全局对象支持 |      |
-    |   `operator new[]()`    | 运算符重载，空实现，用于全局对象支持 |      |
-    |    `operator new()`     | 运算符重载，空实现，用于全局对象支持 |      |
-    |   `operator new[]()`    | 运算符重载，空实现，用于全局对象支持 |      |
-    |   `operator delete()`   | 运算符重载，空实现，用于全局对象支持 |      |
-    |   `operator delete()`   | 运算符重载，空实现，用于全局对象支持 |      |
-    |  `operator delete[]()`  | 运算符重载，空实现，用于全局对象支持 |      |
-    |  `operator delete[]()`  | 运算符重载，空实现，用于全局对象支持 |      |
+- TODO
 
-- 打印函数调用栈
+    riscv64 PLIC
 
-  逐层回溯帧指针后与 elf 信息进行对比，实现对函数调用栈的打印
-
-- 基础 c++ 异常 支持
-
-  通过 throw 抛出异常后停机，没有上下文相关的处理
-
-- klog 内核日志模块
-
-  基于 ANSI 转义码，在支持 ANSI 转义码的终端中可以显示有颜色的字符串
-
-- 基于 u-boot+opensbi 引导的 riscv64 内核
-
-  1. 由 opensbi 进行初始化，直接跳转到内核地址，进入内核逻辑时为 S 态
-  2. gp 寄存器的初始化
-  3. 基于 opensbi 的 printf
-  4. 使用 FIT 打包的内核
-
-- 基于 u-boot 引导的 amd64 内核
-
-  1. 由 u-boot 进行初始化，进入内核时为 64 位状态
-  2. 使用 FIT 打包的内核
-
-- 基于 u-boot+arm-trusted-firmware+optee 的 aarch64 内核
-
-  1. 使用 FIT 打包的内核
-  2. 由 u-boot 进行初始化，进入内核时为 64 位状态
-  3. 使用 atf 框架
-
-- SMP 支持
-
-  多核支持
-
-- spinlock
-
-  适用于多核抢占的自旋锁，主要用于 klog 模块
-
-- dtb 解析
-
-- elf 解析
-
-- ns16550a 串口驱动
-
-- pl011 串口驱动
-
-- 基于 doxygen 的文档生成与自动部署
-
-  github action 会将文档部署到 https://simple-xx.github.io/SimpleKernel/ (仅 main 分支)
-
-- 基于 git submodule 的第三方资源管理
-
-  使用 git submodule 集成第三方资源
-
-- 测试
-
-    支持 单元测试、集成测试、系统测试，引入 gtest 作为测试框架，同时统计了测试覆盖率
-
-- 代码分析
-
-    引入 cppcheck、clang-tidy、sanitize 工具提前发现错误
-
-- 代码格式化
-
-    使用 google 风格
-
-- docker
-
-    支持使用 docker 构建，详细使用方法见 [doc/docker.md](./doc/docker.md)
+    x86_64 APIC
 
 ## 已支持的特性
 
-见 新增特性
+  - [x] [BUILD] 使用 CMake 的构建系统
+
+  - [x] [BUILD] 使用 gdb remote 调试
+
+  - [x] [BUILD] 第三方资源集成
+
+  - [x] [COMMON] C++ 全局对象的构造
+
+  - [x] [COMMON] C++ 静态局部对象构造
+
+  - [x] [COMMON] C 栈保护支持
+
+  - [x] [COMMON] printf 支持
+
+  - [x] [COMMON] 简单的 C++ 异常支持
+
+  - [x] [COMMON] 带颜色的字符串输出
+
+  - [x] [x86_64] 基于 gnuefi 的 bootloader
+
+  - [x] [x86_64] 基于 serial 的基本输出
+
+  - [x] [x86_64] 物理内存信息探测
+
+  - [x] [x86_64] 显示缓冲区探测
+
+  - [x] [x86_64] 调用栈回溯
+
+  - [x] [riscv64] gp 寄存器的初始化
+
+  - [x] [riscv64] 基于 opensbi 的基本输出
+
+  - [x] [riscv64] device tree 硬件信息解析
+
+  - [x] [riscv64] ns16550a 串口驱动
+
+  - [x] [riscv64] 调用栈回溯(仅打印地址)
+
+  - [ ] [aarch64] 基于 gnuefi 的 bootloader(调试中)
 
 ## 使用的第三方资源
 
diff --git a/README_ENG.md b/README_ENG.md
index 093b9636..081a9dae 100644
--- a/README_ENG.md
+++ b/README_ENG.md
@@ -1,7 +1,7 @@
 [![codecov](https://codecov.io/gh/Simple-XX/SimpleKernel/graph/badge.svg?token=J7NKK3SBNJ)](https://codecov.io/gh/Simple-XX/SimpleKernel)
 ![workflow](https://github.com/Simple-XX/SimpleKernel/actions/workflows/workflow.yml/badge.svg)
 ![commit-activity](https://img.shields.io/github/commit-activity/t/Simple-XX/SimpleKernel)
-![last-commit-boot](https://img.shields.io/github/last-commit/Simple-XX/SimpleKernel/boot)
+![last-commit-interrupt](https://img.shields.io/github/last-commit/Simple-XX/SimpleKernel/interrupt)
 ![MIT License](https://img.shields.io/github/license/mashape/apistatus.svg)
 [![LICENSE](https://img.shields.io/badge/license-Anti%20996-blue.svg)](https://github.com/996icu/996.ICU/blob/master/LICENSE)
 [![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu)
@@ -10,7 +10,7 @@
 
 # SimpleKernel
 
-boot branch
+interrupt branch
 
 ## Key Words
 
@@ -63,93 +63,80 @@ Pre-configured VSCode settings for running and debugging the kernel are provided
 
 This branch is the first branch of SimpleKernel. In this branch, we have completed the foundation of the build system, basic documentation deployment, and automated testing. Most importantly, we have implemented a u-boot based x86_64 kernel and a RISC-V64 kernel started by OpenSBI, both of which can run on QEMU and achieve simple screen output.
 
-- Build system
+- riscv64
 
-  References the [MRNIU/cmake-kernel](https://github.com/MRNIU/cmake-kernel) build system. For detailed explanation, see [doc/build_system.md](./doc/build_system.md)
+    1. CSR register abstraction
+    2. Register status printing
+    3. Direct-based interrupt handling
+    4. Interrupt registration functions
+    5. Timer interrupts
 
-- Stack Trace Printing
+- aarch64
 
-  Traverse frame pointers and cross-reference with ELF symbol tables to reconstruct function call stacks.
+    1. Interrupt registration functions
+    2. Timer interrupts
+    3. UART interrupts
+    4. GICv3 driver
 
-- Basic C++ Exception Support
+- x86_64
 
-  Implements throw to trigger exceptions followed by system termination (no context-aware exception handling).
+    1. CPU abstraction
+    2. 8259A PIC controller abstraction
+    3. 8253/8254 timer controller abstraction
+    4. GDT initialization
+    5. Interrupt handling flow
+    6. Interrupt registration functions
+    7. Timer interrupts
 
-- klog Kernel Logging Module
+- TODO
 
-  Supports ANSI escape codes for colored text output in ANSI-compatible terminals.
+    riscv64 PLIC
 
-- RISC-V64 (U-Boot + OpenSBI)
-
-  1. Initialized by OpenSBI; kernel entry in Supervisor (S) mode.
-  2. GP (Global Pointer) register initialization.
-  3. printf implementation leveraging OpenSBI.
-  4. FIT (Flattened Image Tree) image packaging.
-
-- x86_64 (U-Boot)
-
-  1. Initialized by U-Boot; kernel enters 64-bit mode directly.
-  2. FIT image packaging.
-
-- AArch64 (U-Boot + Arm Trusted Firmware + OP-TEE)
-
-  1. FIT image packaging.
-  2. Initialized by U-Boot in 64-bit mode.
-  3. ATF (Arm Trusted Firmware) framework integration.
-
-- SMP Support
-
-  Multi-core CPU coordination and synchronization
-
-- Spinlock
-
-  Preemptive multi-core spinlock implementation (primarily for klog synchronization)
-
-- Device Tree Blob (DTB) Parsing
-
-  Hardware configuration decoding and interpretation
-
-- ELF Parsing
-
-  Executable and Linkable Format analysis
-
-- NS16550A UART Driver
-
-  Serial communication driver for x86/RISC-V platforms
-
-- PL011 UART Driver
-
-  Serial communication driver for ARM platforms
-
-- Doxygen-based Documentation Generation and Automatic Deployment
-
-  GitHub Actions automatically deploys documentation to https://simple-xx.github.io/SimpleKernel/ (main branch only)
-
-- Third-party Resource Management based on Git Submodules
-
-  Uses git submodule to integrate third-party resources
-
-- Testing Framework
-
-  Supports unit testing, integration testing, and system testing using gtest framework with test coverage statistics
-
-- Code Analysis
-
-  Integrates cppcheck, clang-tidy, and sanitize tools for early error detection
-
-- Code Formatting
-
-  Uses Google style formatting
-
-- Docker Support
-
-  Supports building with Docker, see [doc/docker.md](./doc/docker.md)
+    x86_64 APIC
 
 ## Supported Features
 
-See New Features
+  - [x] [BUILD] CMake-based build system
 
-## Third-party Dependencies
+  - [x] [BUILD] GDB remote debugging
+
+  - [x] [BUILD] Third-party resource integration
+
+  - [x] [COMMON] C++ global object construction
+
+  - [x] [COMMON] C++ static local object construction
+
+  - [x] [COMMON] C stack protection support
+
+  - [x] [COMMON] printf support
+
+  - [x] [COMMON] Simple C++ exception support
+
+  - [x] [COMMON] Colored string output
+
+  - [x] [x86_64] gnuefi-based bootloader
+
+  - [x] [x86_64] Serial-based basic output
+
+  - [x] [x86_64] Physical memory information detection
+
+  - [x] [x86_64] Display buffer detection
+
+  - [x] [x86_64] Call stack backtrace
+
+  - [x] [riscv64] GP register initialization
+
+  - [x] [riscv64] OpenSBI-based basic output
+
+  - [x] [riscv64] Device tree hardware information parsing
+
+  - [x] [riscv64] ns16550a serial driver
+
+  - [x] [riscv64] Call stack backtrace (address printing only)
+
+  - [ ] [aarch64] gnuefi-based bootloader (debugging)
+
+## Used Third-party Resources
 
 [google/googletest](https://github.com/google/googletest.git)
 
@@ -173,5 +160,6 @@ See New Features
 
 ## Development Guide
 
-- **Code Style**: Google Style (enforced via .clang-format)
-- **Naming Convention**: [Google Open Source Style Guide](https://google.github.io/styleguide/cppguide.html)
+Code Style: Google, specified by .clang-format
+
+Naming Convention: [Google Open Source Project Style Guide](https://google.github.io/styleguide/cppguide.html)
diff --git a/src/arch/CMakeLists.txt b/src/arch/CMakeLists.txt
index d17b9e47..8dd39df0 100644
--- a/src/arch/CMakeLists.txt
+++ b/src/arch/CMakeLists.txt
@@ -16,6 +16,11 @@ TARGET_SOURCES (
         $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},riscv64>:
         ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/macro.S
         >
+        $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},aarch64>:
+        ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/macro.S
+        ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/interrupt.S
+        >
         ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/boot.S
         ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/arch_main.cpp
-        ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/backtrace.cpp)
+        ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/backtrace.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/${CMAKE_SYSTEM_PROCESSOR}/interrupt.cpp)
diff --git a/src/arch/aarch64/arch_main.cpp b/src/arch/aarch64/arch_main.cpp
index b81ae3f8..cc88f381 100644
--- a/src/arch/aarch64/arch_main.cpp
+++ b/src/arch/aarch64/arch_main.cpp
@@ -18,6 +18,7 @@
 
 #include "arch.h"
 #include "basic_info.hpp"
+#include "interrupt.h"
 #include "kernel_elf.hpp"
 #include "kernel_fdt.hpp"
 #include "per_cpu.hpp"
diff --git a/src/arch/aarch64/interrupt.S b/src/arch/aarch64/interrupt.S
new file mode 100644
index 00000000..587ac019
--- /dev/null
+++ b/src/arch/aarch64/interrupt.S
@@ -0,0 +1,177 @@
+
+/**
+ * @file interrupt.S
+ * @brief aarch64 中断函数
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-04-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-04-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "macro.S"
+
+// clang-format off
+
+.global vector_table
+.balign 0x800
+vector_table:
+// Current EL with SP0
+.balign 0x80
+    b sync_current_el_sp0
+.balign 0x80
+    b irq_current_el_sp0
+.balign 0x80
+    b fiq_current_el_sp0
+.balign 0x80
+    b error_current_el_sp0
+
+// Current EL with SPx
+.balign 0x80
+    b sync_current_el_spx
+.balign 0x80
+    b irq_current_el_spx
+.balign 0x80
+    b fiq_current_el_spx
+.balign 0x80
+    b error_current_el_spx
+
+// Lower EL using AArch64
+.balign 0x80
+    b sync_lower_el_aarch64
+.balign 0x80
+    b irq_lower_el_aarch64
+.balign 0x80
+    b fiq_lower_el_aarch64
+.balign 0x80
+    b error_lower_el_aarch64
+
+// Lower EL using AArch32
+.balign 0x80
+    b sync_lower_el_aarch32
+.balign 0x80
+    b irq_lower_el_aarch32
+.balign 0x80
+    b fiq_lower_el_aarch32
+.balign 0x80
+    b error_lower_el_aarch32
+
+// Exception handlers
+sync_current_el_sp0:
+    savereg
+    mov x0, sp
+    bl sync_current_el_sp0_handler
+    restorereg
+    eret
+
+irq_current_el_sp0:
+    savereg
+    mov x0, sp
+    bl irq_current_el_sp0_handler
+    restorereg
+    eret
+
+fiq_current_el_sp0:
+    savereg
+    mov x0, sp
+    bl fiq_current_el_sp0_handler
+    restorereg
+    eret
+
+error_current_el_sp0:
+    savereg
+    mov x0, sp
+    bl error_current_el_sp0_handler
+    restorereg
+    eret
+
+sync_current_el_spx:
+    savereg
+    mov x0, sp
+    bl sync_current_el_spx_handler
+    restorereg
+    eret
+
+irq_current_el_spx:
+    savereg
+    mov x0, sp
+    bl irq_current_el_spx_handler
+    restorereg
+    eret
+
+fiq_current_el_spx:
+    savereg
+    mov x0, sp
+    bl fiq_current_el_spx_handler
+    restorereg
+    eret
+
+error_current_el_spx:
+    savereg
+    mov x0, sp
+    bl error_current_el_spx_handler
+    restorereg
+    eret
+
+sync_lower_el_aarch64:
+    savereg
+    mov x0, sp
+    bl sync_lower_el_aarch64_handler
+    restorereg
+    eret
+
+irq_lower_el_aarch64:
+    savereg
+    mov x0, sp
+    bl irq_lower_el_aarch64_handler
+    restorereg
+    eret
+
+fiq_lower_el_aarch64:
+    savereg
+    mov x0, sp
+    bl fiq_lower_el_aarch64_handler
+    restorereg
+    eret
+
+error_lower_el_aarch64:
+    savereg
+    mov x0, sp
+    bl error_lower_el_aarch64_handler
+    restorereg
+    eret
+
+sync_lower_el_aarch32:
+    savereg
+    mov x0, sp
+    bl sync_lower_el_aarch32_handler
+    restorereg
+    eret
+
+irq_lower_el_aarch32:
+    savereg
+    mov x0, sp
+    bl irq_lower_el_aarch32_handler
+    restorereg
+    eret
+
+fiq_lower_el_aarch32:
+    savereg
+    mov x0, sp
+    bl fiq_lower_el_aarch32_handler
+    restorereg
+    eret
+
+error_lower_el_aarch32:
+    savereg
+    mov x0, sp
+    bl error_lower_el_aarch32_handler
+    restorereg
+    eret
+
+// clang-format on
diff --git a/src/arch/aarch64/interrupt.cpp b/src/arch/aarch64/interrupt.cpp
new file mode 100644
index 00000000..17074f97
--- /dev/null
+++ b/src/arch/aarch64/interrupt.cpp
@@ -0,0 +1,239 @@
+/**
+ * @file interrupt.cpp
+ * @brief 中断初始化
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "interrupt.h"
+
+#include "io.hpp"
+#include "kernel_fdt.hpp"
+#include "kernel_log.hpp"
+#include "pl011.h"
+#include "sk_cstdio"
+
+/**
+ * @brief 中断处理函数
+ * 由于 aarch64-linux-gnu-g++ 13.2.0 不支持 aarch64 的
+ * __attribute__((interrupt("IRQ"))) 写法，需要手动处理中断函数
+ */
+extern "C" void vector_table();
+
+// 同步异常处理程序
+extern "C" void sync_current_el_sp0_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Sync Exception at Current EL with SP0\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void irq_current_el_sp0_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("IRQ Exception at Current EL with SP0\n");
+  // 处理 IRQ 中断
+  // ...
+}
+
+extern "C" void fiq_current_el_sp0_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("FIQ Exception at Current EL with SP0\n");
+  // 处理 FIQ 中断
+  // ...
+}
+
+extern "C" void error_current_el_sp0_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Error Exception at Current EL with SP0\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void sync_current_el_spx_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Sync Exception at Current EL with SPx\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void irq_current_el_spx_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("IRQ Exception at Current EL with SPx\n");
+  auto cause = cpu_io::ICC_IAR1_EL1::INTID::Get();
+  Singleton<Interrupt>::GetInstance().Do(cause, nullptr);
+  // 处理 IRQ 中断
+  // ...
+}
+
+extern "C" void fiq_current_el_spx_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("FIQ Exception at Current EL with SPx\n");
+  // 处理 FIQ 中断
+  // ...
+}
+
+extern "C" void error_current_el_spx_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Error Exception at Current EL with SPx\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void sync_lower_el_aarch64_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Sync Exception at Lower EL using AArch64\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void irq_lower_el_aarch64_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("IRQ Exception at Lower EL using AArch64\n");
+  // 处理 IRQ 中断
+  // ...
+}
+
+extern "C" void fiq_lower_el_aarch64_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("FIQ Exception at Lower EL using AArch64\n");
+  // 处理 FIQ 中断
+  // ...
+}
+
+extern "C" void error_lower_el_aarch64_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Error Exception at Lower EL using AArch64\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void sync_lower_el_aarch32_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Sync Exception at Lower EL using AArch32\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+extern "C" void irq_lower_el_aarch32_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("IRQ Exception at Lower EL using AArch32\n");
+  // 处理 IRQ 中断
+  // ...
+}
+
+extern "C" void fiq_lower_el_aarch32_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("FIQ Exception at Lower EL using AArch32\n");
+  // 处理 FIQ 中断
+  // ...
+}
+
+extern "C" void error_lower_el_aarch32_handler(
+    uint64_t sp __attribute_maybe_unused__) {
+  klog::Err("Error Exception at Lower EL using AArch32\n");
+  while (true) {
+    asm volatile("wfi");
+  }
+}
+
+auto timer_handler(uint64_t cause, uint8_t *) -> uint64_t {
+  klog::Info("Timer interrupt\n");
+  // 2s
+  uint64_t interval_clk = 2 * cpu_io::CNTFRQ_EL0::Read();
+  cpu_io::CNTV_TVAL_EL0::Write(interval_clk);
+  return cause;
+}
+
+auto uart_handler(uint64_t cause, uint8_t *) -> uint64_t {
+  klog::Info("%c", Singleton<Pl011>::GetInstance().GetChar());
+  return cause;
+}
+
+std::array<Interrupt::InterruptFunc, Interrupt::kMaxInterrupt>
+    Interrupt::interrupt_handlers;
+
+Interrupt::Interrupt() {
+  auto [gicd_base_addr, gicr_base_addr] =
+      Singleton<KernelFdt>::GetInstance().GetGic();
+  gic_ = std::move(Gic(gicd_base_addr, gicr_base_addr));
+
+  // 注册默认中断处理函数
+  for (auto &i : interrupt_handlers) {
+    i = [](uint64_t cause, uint8_t *context) -> uint64_t {
+      klog::Info("Default Interrupt handler 0x%X, 0x%p\n", cause, context);
+      return 0;
+    };
+  }
+
+  klog::Info("Interrupt init.\n");
+}
+
+void Interrupt::Do(uint64_t cause, uint8_t *context) {
+  auto ret = interrupt_handlers[cause](cause, context);
+
+  if (ret) {
+    cpu_io::ICC_EOIR1_EL1::Write(cause);
+  }
+}
+
+void Interrupt::RegisterInterruptFunc(uint64_t cause, InterruptFunc func) {
+  if (func) {
+    interrupt_handlers[cause] = func;
+  }
+}
+
+auto InterruptInit(int, const char **) -> int {
+  klog::Info("Hello InterruptInit\n");
+
+  cpu_io::VBAR_EL1::Write(reinterpret_cast<uint64_t>(vector_table));
+
+  auto timer_intid =
+      Singleton<KernelFdt>::GetInstance().GetAarch64Intid("arm,armv8-timer") +
+      Gic::kPPIBase;
+
+  auto uart_intid =
+      Singleton<KernelFdt>::GetInstance().GetAarch64Intid("arm,pl011") +
+      Gic::kSPIBase;
+
+  klog::Info("timer_intid: %d, uart_intid: %d\n", timer_intid, uart_intid);
+
+  Singleton<Interrupt>::GetInstance().SPI(uart_intid);
+  Singleton<Interrupt>::GetInstance().PPI(timer_intid, 0);
+
+  Singleton<Interrupt>::GetInstance().RegisterInterruptFunc(timer_intid,
+                                                            timer_handler);
+
+  // 注册 uart 中断处理函数
+  Singleton<Interrupt>::GetInstance().RegisterInterruptFunc(uart_intid,
+                                                            uart_handler);
+
+  cpu_io::EnableInterrupt();
+
+  cpu_io::CNTV_CTL_EL0::ENABLE::Clear();
+  cpu_io::CNTV_CTL_EL0::IMASK::Set();
+
+  uint64_t interval_clk = 2 * cpu_io::CNTFRQ_EL0::Read();
+  cpu_io::CNTV_TVAL_EL0::Write(interval_clk);
+
+  cpu_io::CNTV_CTL_EL0::ENABLE::Set();
+  cpu_io::CNTV_CTL_EL0::IMASK::Clear();
+
+  return 0;
+}
+
+auto InterruptInitSMP(int, const char **) -> int {}
diff --git a/src/arch/aarch64/interrupt.h b/src/arch/aarch64/interrupt.h
new file mode 100644
index 00000000..d5731f2b
--- /dev/null
+++ b/src/arch/aarch64/interrupt.h
@@ -0,0 +1,69 @@
+
+/**
+ * @file interrupt.h
+ * @brief interrupt 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_ARCH_AARCH64_INCLUDE_INTERRUPT_H_
+#define SIMPLEKERNEL_SRC_KERNEL_ARCH_AARCH64_INCLUDE_INTERRUPT_H_
+
+#include <cpu_io.h>
+
+#include <cstdint>
+
+#include "gic.h"
+#include "interrupt_base.h"
+#include "singleton.hpp"
+#include "sk_stdio.h"
+
+class Interrupt final : public InterruptBase {
+ public:
+  static constexpr const size_t kMaxInterrupt = 128;
+
+  Interrupt();
+
+  /// @name 构造/析构函数
+  /// @{
+  Interrupt(const Interrupt &) = delete;
+  Interrupt(Interrupt &&) = delete;
+  auto operator=(const Interrupt &) -> Interrupt & = delete;
+  auto operator=(Interrupt &&) -> Interrupt & = delete;
+  ~Interrupt() = default;
+  /// @}
+
+  /**
+   * @brief 执行中断处理
+   * @param  cause 中断或异常号
+   * @param  context 中断上下文
+   */
+  void Do(uint64_t cause, uint8_t *context) override;
+
+  /**
+   * @brief 注册中断处理函数
+   * @param cause 中断原因
+   * @param func 处理函数
+   */
+  void RegisterInterruptFunc(uint64_t cause, InterruptFunc func) override;
+
+  __always_inline void SPI(uint32_t intid) const { gic_.SPI(intid); }
+  __always_inline void PPI(uint32_t intid, uint32_t cpuid) const {
+    gic_.PPI(intid, cpuid);
+  }
+
+ private:
+  static std::array<InterruptFunc, kMaxInterrupt> interrupt_handlers;
+
+  Gic gic_;
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_ARCH_AARCH64_INCLUDE_INTERRUPT_H_ */
diff --git a/src/arch/aarch64/macro.S b/src/arch/aarch64/macro.S
new file mode 100644
index 00000000..d007b5ea
--- /dev/null
+++ b/src/arch/aarch64/macro.S
@@ -0,0 +1,72 @@
+
+/**
+ * @file macro.S
+ * @brief aarch64 汇编宏
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-04-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-04-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+// clang-format off
+
+.macro savereg
+    // make room to save registers.
+    sub sp, sp, #272
+
+    // save the registers.
+    stp x0, x1, [sp, #16 * 0]
+    stp x2, x3, [sp, #16 * 1]
+    stp x4, x5, [sp, #16 * 2]
+    stp x6, x7, [sp, #16 * 3]
+    stp x8, x9, [sp, #16 * 4]
+    stp x10, x11, [sp, #16 * 5]
+    stp x12, x13, [sp, #16 * 6]
+    stp x14, x15, [sp, #16 * 7]
+    stp x16, x17, [sp, #16 * 8]
+    stp x18, x19, [sp, #16 * 9]
+    stp x20, x21, [sp, #16 * 10]
+    stp x22, x23, [sp, #16 * 11]
+    stp x24, x25, [sp, #16 * 12]
+    stp x26, x27, [sp, #16 * 13]
+    stp x28, x29, [sp, #16 * 14]
+    mrs x9, elr_el1
+    mrs x10, spsr_el1
+    add x11, sp, #272
+    stp x30, x9, [sp, #16 * 15]
+    stp x10, x11, [sp, #16 * 16]
+.endm
+
+.macro restorereg
+    ldp x30, x9, [sp, #16 * 15]
+    ldp x10, x11, [sp, #16 * 16]
+
+    msr elr_el1, x9
+    msr spsr_el1, x10
+
+    ldp x0, x1, [sp, #16 * 0]
+    ldp x2, x3, [sp, #16 * 1]
+    ldp x4, x5, [sp, #16 * 2]
+    ldp x6, x7, [sp, #16 * 3]
+    ldp x8, x9, [sp, #16 * 4]
+    ldp x10, x11, [sp, #16 * 5]
+    ldp x12, x13, [sp, #16 * 6]
+    ldp x14, x15, [sp, #16 * 7]
+    ldp x16, x17, [sp, #16 * 8]
+    ldp x18, x19, [sp, #16 * 9]
+    ldp x20, x21, [sp, #16 * 10]
+    ldp x22, x23, [sp, #16 * 11]
+    ldp x24, x25, [sp, #16 * 12]
+    ldp x26, x27, [sp, #16 * 13]
+    ldp x28, x29, [sp, #16 * 14]
+    add sp, sp, #272
+.endm
+
+
+// clang-format on
diff --git a/src/arch/riscv64/arch_main.cpp b/src/arch/riscv64/arch_main.cpp
index 73c8fd96..15eaa09d 100644
--- a/src/arch/riscv64/arch_main.cpp
+++ b/src/arch/riscv64/arch_main.cpp
@@ -64,15 +64,6 @@ void ArchInit(int argc, const char **argv) {
       KernelElf(Singleton<BasicInfo>::GetInstance().elf_addr);
 
   klog::Info("Hello riscv64 ArchInit\n");
-
-  // 唤醒其余 core
-  for (size_t i = 0; i < Singleton<BasicInfo>::GetInstance().core_count; i++) {
-    auto ret = sbi_hart_start(i, reinterpret_cast<uint64_t>(_boot), 0);
-    if ((ret.error != SBI_SUCCESS) &&
-        (ret.error != SBI_ERR_ALREADY_AVAILABLE)) {
-      klog::Warn("hart %d start failed: %d\n", i, ret.error);
-    }
-  }
 }
 
 void ArchInitSMP(int, const char **) {}
diff --git a/src/arch/riscv64/interrupt.cpp b/src/arch/riscv64/interrupt.cpp
new file mode 100644
index 00000000..451e418d
--- /dev/null
+++ b/src/arch/riscv64/interrupt.cpp
@@ -0,0 +1,231 @@
+/**
+ * @file interrupt.cpp
+ * @brief 中断初始化
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "interrupt.h"
+
+#include <cpu_io.h>
+
+#include "basic_info.hpp"
+#include "kernel_fdt.hpp"
+#include "kernel_log.hpp"
+#include "ns16550a.h"
+#include "opensbi_interface.h"
+#include "sk_cstdio"
+#include "sk_iostream"
+
+alignas(4) std::array<Interrupt::InterruptFunc,
+                      cpu_io::detail::register_info::csr::ScauseInfo::
+                          kInterruptMaxCount> Interrupt::interrupt_handlers_;
+/// 异常处理函数数组
+alignas(4) std::array<Interrupt::InterruptFunc,
+                      cpu_io::detail::register_info::csr::ScauseInfo::
+                          kExceptionMaxCount> Interrupt::exception_handlers_;
+
+__attribute__((interrupt("supervisor"))) alignas(4) static void TarpEntry() {
+  Singleton<Interrupt>::GetInstance().Do(
+      static_cast<uint64_t>(cpu_io::Scause::Read()), nullptr);
+}
+
+Interrupt::Interrupt() {
+  // 注册默认中断处理函数
+  for (auto &i : interrupt_handlers_) {
+    i = [](uint64_t cause, uint8_t *context) -> uint64_t {
+      klog::Info("Default Interrupt handler [%s] 0x%X, 0x%p\n",
+                 cpu_io::detail::register_info::csr::ScauseInfo::kInterruptNames
+                     [cause],
+                 cause, context);
+      return 0;
+    };
+  }
+  // 注册默认异常处理函数
+  for (auto &i : exception_handlers_) {
+    i = [](uint64_t cause, uint8_t *context) -> uint64_t {
+      klog::Err("Default Exception handler [%s] 0x%X, 0x%p\n",
+                cpu_io::detail::register_info::csr::ScauseInfo::kExceptionNames
+                    [cause],
+                cause, context);
+      while (1);
+      return 0;
+    };
+  }
+  klog::Info("Interrupt init.\n");
+}
+
+void Interrupt::Do(uint64_t cause, uint8_t *context) {
+  auto interrupt = cpu_io::Scause::Interrupt::Get(cause);
+  auto exception_code = cpu_io::Scause::ExceptionCode::Get(cause);
+
+  if (interrupt) {
+    // 中断
+    if (exception_code <
+        cpu_io::detail::register_info::csr::ScauseInfo::kInterruptMaxCount) {
+      interrupt_handlers_[exception_code](exception_code, context);
+    }
+  } else {
+    // 异常
+    if (exception_code <
+        cpu_io::detail::register_info::csr::ScauseInfo::kExceptionMaxCount) {
+      exception_handlers_[exception_code](exception_code, context);
+    }
+  }
+}
+
+void Interrupt::RegisterInterruptFunc(uint64_t cause, InterruptFunc func) {
+  auto interrupt = cpu_io::Scause::Interrupt::Get(cause);
+  auto exception_code = cpu_io::Scause::ExceptionCode::Get(cause);
+
+  if (interrupt) {
+    if (exception_code <
+        cpu_io::detail::register_info::csr::ScauseInfo::kInterruptMaxCount) {
+      interrupt_handlers_[exception_code] = func;
+      klog::Info("RegisterInterruptFunc [%s] 0x%X, 0x%p\n",
+                 cpu_io::detail::register_info::csr::ScauseInfo::kInterruptNames
+                     [exception_code],
+                 cause, func);
+    }
+  } else {
+    if (exception_code <
+        cpu_io::detail::register_info::csr::ScauseInfo::kExceptionMaxCount) {
+      exception_handlers_[exception_code] = func;
+      klog::Info("RegisterInterruptFunc [%s] 0x%X, 0x%p\n",
+                 cpu_io::detail::register_info::csr::ScauseInfo::kExceptionNames
+                     [exception_code],
+                 cause, func);
+    }
+  }
+}
+
+static uint64_t kInterval = 0;
+
+auto InterruptInit(int, const char **) -> int {
+  // 获取 cpu 速度
+  kInterval = Singleton<KernelFdt>::GetInstance().GetTimebaseFrequency();
+  klog::Info("kInterval: 0x%X\n", kInterval);
+
+  // 注册时钟中断
+  Singleton<Interrupt>::GetInstance().RegisterInterruptFunc(
+      cpu_io::detail::register_info::csr::ScauseInfo::kSupervisorTimerInterrupt,
+      [](uint64_t exception_code, uint8_t *) -> uint64_t {
+        sbi_set_timer(cpu_io::Time::Read() + kInterval);
+        klog::Info("Handle %s\n",
+                   cpu_io::detail::register_info::csr::ScauseInfo::
+                       kInterruptNames[exception_code]);
+        return 0;
+      });
+
+  // 注册外部中断
+  Singleton<Interrupt>::GetInstance().RegisterInterruptFunc(
+      cpu_io::detail::register_info::csr::ScauseInfo::
+          kSupervisorExternalInterrupt,
+      [](uint64_t exception_code, uint8_t *) -> uint64_t {
+        // 获取触发中断的源 ID
+        auto source_id = Singleton<Plic>::GetInstance().Which();
+        if (source_id != 0) {
+          klog::Info("External interrupt from source %d\n", source_id);
+          // 告知 PLIC 中断已处理完成
+          Singleton<Plic>::GetInstance().Done(source_id);
+        }
+        klog::Info("Handle %s\n",
+                   cpu_io::detail::register_info::csr::ScauseInfo::
+                       kInterruptNames[exception_code]);
+        return 0;
+      });
+
+  // ebreak 中断
+  Singleton<Interrupt>::GetInstance().RegisterInterruptFunc(
+      cpu_io::detail::register_info::csr::ScauseInfo::kBreakpoint,
+      [](uint64_t exception_code, uint8_t *) -> uint64_t {
+        cpu_io::Sepc::Write(cpu_io::Sepc::Read() + 2);
+        klog::Info("Handle %s\n",
+                   cpu_io::detail::register_info::csr::ScauseInfo::
+                       kExceptionNames[exception_code]);
+        return 0;
+      });
+
+  // 初始化 plic
+  auto [plic_addr, plic_size, ndev, context_count] =
+      Singleton<KernelFdt>::GetInstance().GetPlic();
+  Singleton<Plic>::GetInstance() =
+      std::move(Plic(plic_addr, ndev, context_count));
+
+  // 设置 trap vector
+  cpu_io::Stvec::SetDirect(reinterpret_cast<uint64_t>(TarpEntry));
+
+  // 开启 Supervisor 中断
+  cpu_io::Sstatus::Sie::Set();
+
+  // 开启内部中断
+  cpu_io::Sie::Ssie::Set();
+
+  // 开启时钟中断
+  cpu_io::Sie::Stie::Set();
+
+  // 开启外部中断
+  cpu_io::Sie::Seie::Set();
+
+  asm("ebreak");
+
+  // 设置时钟中断时间
+  // sbi_set_timer(kInterval);
+
+  klog::Info("Hello InterruptInit\n");
+
+  Singleton<Plic>::GetInstance().Set(0, 10, 1, 1);
+  Singleton<Plic>::GetInstance().Set(1, 10, 1, 1);
+
+  auto [base, size] = Singleton<KernelFdt>::GetInstance().GetSerial();
+  auto serial = Ns16550a(base);
+  auto ret = serial.GetChar();
+  klog::Info("Get char: %c\n", ret);
+
+  while (1);
+
+  // 唤醒其余 core
+  for (size_t i = 0; i < Singleton<BasicInfo>::GetInstance().core_count; i++) {
+    auto ret = sbi_hart_start(i, reinterpret_cast<uint64_t>(_boot), 0);
+    if ((ret.error != SBI_SUCCESS) &&
+        (ret.error != SBI_ERR_ALREADY_AVAILABLE)) {
+      klog::Warn("hart %d start failed: %d\n", i, ret.error);
+    }
+  }
+
+  return 0;
+}
+
+auto InterruptInitSMP(int, const char **) -> int {
+  // 设置 trap vector
+  cpu_io::Stvec::SetDirect(reinterpret_cast<uint64_t>(TarpEntry));
+
+  // 开启 Supervisor 中断
+  cpu_io::Sstatus::Sie::Set();
+
+  // 开启内部中断
+  cpu_io::Sie::Ssie::Set();
+
+  // 开启时钟中断
+  cpu_io::Sie::Stie::Set();
+
+  // 开启外部中断
+  cpu_io::Sie::Seie::Set();
+
+  asm("ebreak");
+
+  // 设置时钟中断时间
+  sbi_set_timer(kInterval);
+
+  klog::Info("Hello InterruptInitSMP\n");
+
+  return 0;
+}
diff --git a/src/arch/riscv64/interrupt.h b/src/arch/riscv64/interrupt.h
new file mode 100644
index 00000000..7d5bcddd
--- /dev/null
+++ b/src/arch/riscv64/interrupt.h
@@ -0,0 +1,70 @@
+
+/**
+ * @file interrupt.h
+ * @brief 中断处理
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_ARCH_RISCV64_INTERRUPT_H_
+#define SIMPLEKERNEL_SRC_KERNEL_ARCH_RISCV64_INTERRUPT_H_
+
+#include <cpu_io.h>
+
+#include <array>
+#include <cstdint>
+
+#include "interrupt_base.h"
+#include "plic.h"
+#include "singleton.hpp"
+#include "sk_stdio.h"
+
+class Interrupt final : public InterruptBase {
+ public:
+  Interrupt();
+
+  /// @name 构造/析构函数
+  /// @{
+  Interrupt(const Interrupt &) = delete;
+  Interrupt(Interrupt &&) = delete;
+  auto operator=(const Interrupt &) -> Interrupt & = delete;
+  auto operator=(Interrupt &&) -> Interrupt & = delete;
+  ~Interrupt() = default;
+  /// @}
+
+  /**
+   * @brief 执行中断处理
+   * @param  cause 中断或异常号
+   * @param  context 中断上下文
+   */
+  void Do(uint64_t cause, uint8_t *context) override;
+
+  /**
+   * @brief 注册中断处理函数
+   * @param cause 中断原因
+   * @param func 处理函数
+   */
+  void RegisterInterruptFunc(uint64_t cause, InterruptFunc func) override;
+
+ private:
+  /// 中断处理函数数组
+  static std::array<
+      InterruptFunc,
+      cpu_io::detail::register_info::csr::ScauseInfo::kInterruptMaxCount>
+      interrupt_handlers_;
+  /// 异常处理函数数组
+  static std::array<
+      InterruptFunc,
+      cpu_io::detail::register_info::csr::ScauseInfo::kExceptionMaxCount>
+      exception_handlers_;
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_ARCH_RISCV64_INTERRUPT_H_ */
diff --git a/src/arch/riscv64/macro.S b/src/arch/riscv64/macro.S
index ba77c4c9..8ff8fcc9 100644
--- a/src/arch/riscv64/macro.S
+++ b/src/arch/riscv64/macro.S
@@ -18,29 +18,43 @@
 
 // 寄存器长度，8 字节
 .equ kRegsBytes, 8
+
 // 所有寄存器数量
 .equ kAllRegsCount, 71
+
+// 被调用者保存寄存器数量
+.equ kCalleeSaveRegs, 25
+
+// 调用者保存寄存器数量
+.equ kCallerSaveRegs, 35
+
+// 保存被调用者保存寄存器需要的大小
+.equ CALLEE_SIZE, (kCalleeSaveRegs * kRegsBytes)
+
+// 保存调用者保存寄存器需要的大小
+.equ CALLER_SIZE, (kCallerSaveRegs * kRegsBytes)
+
 // 保存所有寄存器需要的大小
 .equ kAllRegsSize, (kAllRegsCount * kRegsBytes)
 
 // 将寄存器 a 保存在 c 偏移 b 的位置
 .macro SdBase a, b, c
-sd \a, ((\b) * kRegsBytes)(\c)
+    sd \a, ((\b) * kRegsBytes)(\c)
 .endm
 
 // 从 c 的偏移 b 处获取数据并赋值给寄存器 a
 .macro LdBase a, b, c
-ld \a, ((\b) * kRegsBytes)(\c)
+    ld \a, ((\b) * kRegsBytes)(\c)
 .endm
 
 // 将 float 寄存器 a 保存在 c 偏移 b 的位置
 .macro FsdBase a, b, c
-fsd \a, ((\b) * kRegsBytes)(\c)
+    fsd \a, ((\b) * kRegsBytes)(\c)
 .endm
 
 // 从 c 的偏移 b 处获取数据并赋值给 float 寄存器 a
 .macro FldBase a, b, c
-fld \a, ((\b) * kRegsBytes)(\c)
+    fld \a, ((\b) * kRegsBytes)(\c)
 .endm
 
 // clang-format on
diff --git a/src/arch/x86_64/arch_main.cpp b/src/arch/x86_64/arch_main.cpp
index b2b97915..7f2a0270 100644
--- a/src/arch/x86_64/arch_main.cpp
+++ b/src/arch/x86_64/arch_main.cpp
@@ -16,6 +16,7 @@
 
 #include <cpu_io.h>
 
+#include <array>
 #include <cstdint>
 
 #include "basic_info.hpp"
@@ -25,14 +26,79 @@
 #include "singleton.hpp"
 #include "sk_iostream"
 
+namespace {
 // 基本输出实现
 /// @note 这里要注意，保证在 serial 初始化之前不能使用 printf
 /// 函数，否则会有全局对象依赖问题
-namespace {
 cpu_io::Serial kSerial(cpu_io::kCom1);
 extern "C" void sk_putchar(int c, [[maybe_unused]] void *ctx) {
   kSerial.Write(c);
 }
+
+/// gdt 描述符表，顺序与 cpu_io::detail::register_info::GdtrInfo 中的定义一致
+std::array<cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor,
+           cpu_io::detail::register_info::GdtrInfo::kMaxCount>
+    kSegmentDescriptors = {
+        // 第一个全 0
+        cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor(),
+        // 内核代码段描述符
+        cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor(
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::Type::
+                kCodeExecuteRead,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::S::
+                kCodeData,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::DPL::
+                kRing0,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::P::
+                kPresent,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::AVL::
+                kNotAvailable,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::L::
+                k64Bit),
+        // 内核数据段描述符
+        cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor(
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::Type::
+                kDataReadWrite,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::S::
+                kCodeData,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::DPL::
+                kRing0,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::P::
+                kPresent,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::AVL::
+                kNotAvailable,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::L::
+                k64Bit),
+        // 用户代码段描述符
+        cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor(
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::Type::
+                kCodeExecuteRead,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::S::
+                kCodeData,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::DPL::
+                kRing3,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::P::
+                kPresent,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::AVL::
+                kNotAvailable,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::L::
+                k64Bit),
+        // 用户数据段描述符
+        cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor(
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::Type::
+                kDataReadWrite,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::S::
+                kCodeData,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::DPL::
+                kRing3,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::P::
+                kPresent,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::AVL::
+                kNotAvailable,
+            cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor::L::
+                k64Bit),
+};
+
 }  // namespace
 
 BasicInfo::BasicInfo(int argc, const char **argv) {
@@ -69,6 +135,59 @@ auto ArchInit(int argc, const char **argv) -> int {
       KernelElf(Singleton<BasicInfo>::GetInstance().elf_addr,
                 Singleton<BasicInfo>::GetInstance().elf_size);
 
+  // 加载描述符
+  cpu_io::detail::register_info::GdtrInfo::Gdtr gdtr{
+      .limit =
+          (sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+           cpu_io::detail::register_info::GdtrInfo::kMaxCount) -
+          1,
+      .base = kSegmentDescriptors.data(),
+  };
+  cpu_io::Gdtr::Write(gdtr);
+
+  klog::Debug(
+      "sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor): "
+      "%d\n",
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor));
+  klog::Debug("kSegmentDescriptors: 0x%X\n", kSegmentDescriptors);
+
+  // 加载内核数据段描述符
+  cpu_io::Ds::Write(
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+      cpu_io::detail::register_info::GdtrInfo::kKernelDataIndex);
+  cpu_io::Es::Write(
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+      cpu_io::detail::register_info::GdtrInfo::kKernelDataIndex);
+  cpu_io::Fs::Write(
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+      cpu_io::detail::register_info::GdtrInfo::kKernelDataIndex);
+  cpu_io::Gs::Write(
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+      cpu_io::detail::register_info::GdtrInfo::kKernelDataIndex);
+  cpu_io::Ss::Write(
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+      cpu_io::detail::register_info::GdtrInfo::kKernelDataIndex);
+  // 加载内核代码段描述符
+  cpu_io::Cs::Write(
+      sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor) *
+      cpu_io::detail::register_info::GdtrInfo::kKernelCodeIndex);
+
+  //   sk_std::cout << "es: " << cpu_io::kAllCr.es << sk_std::endl;
+  //   sk_std::cout << "cs: " << cpu_io::kAllCr.cs << sk_std::endl;
+  //   sk_std::cout << "ss: " << cpu_io::kAllCr.ss << sk_std::endl;
+  //   sk_std::cout << "ds: " << cpu_io::kAllCr.ds << sk_std::endl;
+  //   sk_std::cout << "fs: " << cpu_io::kAllCr.fs << sk_std::endl;
+  //   sk_std::cout << "gs: " << cpu_io::kAllCr.gs << sk_std::endl;
+
+  for (size_t i = 0;
+       i <
+       (cpu_io::Gdtr::Read().limit + 1) /
+           sizeof(cpu_io::detail::register_info::GdtrInfo::SegmentDescriptor);
+       i++) {
+    klog::Debug("gdtr[%d] 0x%p\n", i, cpu_io::Gdtr::Read().base + i);
+    // klog::debug << *(cpu_io::kAllCr.gdtr.Read().base + i) << sk_std::endl;
+  }
+
   klog::Info("Hello x86_64 ArchInit\n");
 
   return 0;
diff --git a/src/arch/x86_64/interrupt.cpp b/src/arch/x86_64/interrupt.cpp
new file mode 100644
index 00000000..9ab7af66
--- /dev/null
+++ b/src/arch/x86_64/interrupt.cpp
@@ -0,0 +1,156 @@
+/**
+ * @file interrupt.cpp
+ * @brief 中断初始化
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "interrupt.h"
+
+#include <cpu_io.h>
+
+#include "arch.h"
+#include "kernel_log.hpp"
+#include "sk_cstdio"
+#include "sk_iostream"
+
+std::array<Interrupt::InterruptFunc,
+           cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount>
+    Interrupt::interrupt_handlers;
+
+std::array<cpu_io::detail::register_info::IdtrInfo::Idt,
+           cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount>
+    Interrupt::idts;
+
+/**
+ * @brief 中断处理函数
+ * @tparam no 中断号
+ * @param interrupt_context 中断上下文，根据中断不同可能是 InterruptContext 或
+ * InterruptContextErrorCode
+ */
+template <uint8_t no>
+__attribute__((target("general-regs-only")))
+__attribute__((interrupt)) static void
+TarpEntry(uint8_t *interrupt_context) {
+  Singleton<Interrupt>::GetInstance().Do(no, interrupt_context);
+}
+
+template <uint8_t no>
+void Interrupt::SetUpIdtr() {
+  if constexpr (no <
+                cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount -
+                    1) {
+    idts[no] = cpu_io::detail::register_info::IdtrInfo::Idt(
+        reinterpret_cast<uint64_t>(TarpEntry<no>), 8, 0x0,
+        cpu_io::detail::register_info::IdtrInfo::Idt::Type::k64BitInterruptGate,
+        cpu_io::detail::register_info::IdtrInfo::Idt::DPL::kRing0,
+        cpu_io::detail::register_info::IdtrInfo::Idt::P::kPresent);
+    SetUpIdtr<no + 1>();
+  } else {
+    // 写入 idtr
+    static auto idtr = cpu_io::detail::register_info::IdtrInfo::Idtr{
+        .limit =
+            sizeof(cpu_io::detail::register_info::IdtrInfo::Idtr) *
+                cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount -
+            1,
+        .base = idts.data(),
+    };
+    cpu_io::Idtr::Write(idtr);
+
+    // 输出 idtr 信息
+    // sk_std::cout << cpu::kAllCr.idtr << sk_std::endl;
+    for (size_t i = 0;
+         i < (cpu_io::Idtr::Read().limit + 1) /
+                 sizeof(cpu_io::detail::register_info::IdtrInfo::Idtr);
+         i++) {
+      klog::Debug("idtr[%d] 0x%p\n", i, cpu_io::Idtr::Read().base + i);
+      // klog::debug << *(cpu::kAllCr.idtr.Read().base + i) << sk_std::endl;
+    }
+  }
+}
+
+Interrupt::Interrupt()
+    : pic_(cpu_io::detail::register_info::IdtrInfo::kIrq0,
+           cpu_io::detail::register_info::IdtrInfo::kIrq8),
+      pit_(200) {
+  // 注册默认中断处理函数
+  for (auto &i : interrupt_handlers) {
+    i = [](uint64_t cause, uint8_t *context) -> uint64_t {
+      klog::Info(
+          "Default Interrupt handler [%s] 0x%X, 0x%p\n",
+          cpu_io::detail::register_info::IdtrInfo::kInterruptNames[cause],
+          cause, context);
+      DumpStack();
+      while (true) {
+        ;
+      }
+    };
+  }
+
+  // 初始化 idtr
+  SetUpIdtr();
+
+  // 初始化 loacl apic
+
+  // 初始化 io apic
+
+  klog::Info("Interrupt init.\n");
+}
+
+void Interrupt::Do(uint64_t cause, uint8_t *context) {
+  if (cause < cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount) {
+    interrupt_handlers[cause](cause, context);
+  }
+}
+
+void Interrupt::RegisterInterruptFunc(uint64_t cause, InterruptFunc func) {
+  if (cause < cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount) {
+    interrupt_handlers[cause] = func;
+    klog::Debug("RegisterInterruptFunc [%s] 0x%X, 0x%p\n",
+                cpu_io::detail::register_info::IdtrInfo::kInterruptNames[cause],
+                cause, func);
+  }
+}
+
+auto InterruptInit(int, const char **) -> int {
+  // 初始化中断
+  Singleton<Interrupt>::GetInstance();
+
+  // 注册时钟中断
+  Singleton<Interrupt>::GetInstance().RegisterInterruptFunc(
+      cpu_io::detail::register_info::IdtrInfo::kIrq0,
+      [](uint64_t exception_code, uint8_t *) -> uint64_t {
+        Singleton<Interrupt>::GetInstance().pit_.Ticks();
+        if (Singleton<Interrupt>::GetInstance().pit_.GetTicks() % 100 == 0) {
+          klog::Info("Handle %d %s\n", exception_code,
+                     cpu_io::detail::register_info::IdtrInfo::kInterruptNames
+                         [exception_code]);
+        }
+        Singleton<Interrupt>::GetInstance().pic_.Clear(exception_code);
+        return 0;
+      });
+
+  // 允许时钟中断
+  Singleton<Interrupt>::GetInstance().pic_.Enable(
+      cpu_io::detail::register_info::IdtrInfo::kIrq0);
+  // 开启中断
+  cpu_io::Rflags::If::Set();
+
+  klog::Info("Hello InterruptInit\n");
+
+  return 0;
+}
+
+auto InterruptInitSMP(int, const char **) -> int {
+  klog::Info("Hello InterruptInitSMP\n");
+
+  return 0;
+}
diff --git a/src/arch/x86_64/interrupt.h b/src/arch/x86_64/interrupt.h
new file mode 100644
index 00000000..3b21b916
--- /dev/null
+++ b/src/arch/x86_64/interrupt.h
@@ -0,0 +1,76 @@
+
+/**
+ * @file interrupt.h
+ * @brief 中断处理
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_ARCH_X86_64_INTERRUPT_H_
+#define SIMPLEKERNEL_SRC_KERNEL_ARCH_X86_64_INTERRUPT_H_
+
+#include <cpu_io.h>
+
+#include <array>
+#include <cstdint>
+
+#include "interrupt_base.h"
+#include "singleton.hpp"
+#include "sk_stdio.h"
+
+class Interrupt final : public InterruptBase {
+ public:
+  cpu_io::Pic pic_;
+  cpu_io::Pit pit_;
+
+  Interrupt();
+
+  /// @name 构造/析构函数
+  /// @{
+  Interrupt(const Interrupt &) = delete;
+  Interrupt(Interrupt &&) = delete;
+  auto operator=(const Interrupt &) -> Interrupt & = delete;
+  auto operator=(Interrupt &&) -> Interrupt & = delete;
+  ~Interrupt() override = default;
+  /// @}
+
+  /**
+   * @brief 执行中断处理
+   * @param  cause 中断或异常号
+   * @param  context 中断上下文
+   */
+  void Do(uint64_t cause, uint8_t *context) override;
+
+  /**
+   * @brief 注册中断处理函数
+   * @param cause 中断原因
+   * @param func 处理函数
+   */
+  void RegisterInterruptFunc(uint64_t cause, InterruptFunc func) override;
+
+ private:
+  /// 中断处理函数数组
+  static std::array<InterruptFunc,
+                    cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount>
+      interrupt_handlers;
+
+  static std::array<cpu_io::detail::register_info::IdtrInfo::Idt,
+                    cpu_io::detail::register_info::IdtrInfo::kInterruptMaxCount>
+      idts;
+
+  /**
+   * @brief 初始化 idtr
+   */
+  template <uint8_t no = 0>
+  void SetUpIdtr();
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_ARCH_X86_64_INTERRUPT_H_ */
diff --git a/src/arch/x86_64/macro.S b/src/arch/x86_64/macro.S
new file mode 100644
index 00000000..c9f8f1c0
--- /dev/null
+++ b/src/arch/x86_64/macro.S
@@ -0,0 +1,19 @@
+
+/**
+ * @file macro.S
+ * @brief x86_64 汇编宏
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-04-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-04-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+// clang-format off
+
+// clang-format on
diff --git a/src/driver/8259a/8259a.cpp b/src/driver/8259a/8259a.cpp
new file mode 100644
index 00000000..763118b1
--- /dev/null
+++ b/src/driver/8259a/8259a.cpp
@@ -0,0 +1,21 @@
+
+/**
+ * @file 8259a.h
+ * @brief 8259a 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "8259a.h"
+
+#include "io.hpp"
+
+PIC8259A::PIC8259A(uint64_t dev_addr) : base_addr_(dev_addr) {}
diff --git a/src/driver/8259a/CMakeLists.txt b/src/driver/8259a/CMakeLists.txt
new file mode 100644
index 00000000..08182647
--- /dev/null
+++ b/src/driver/8259a/CMakeLists.txt
@@ -0,0 +1,10 @@
+# This file is a part of Simple-XX/SimpleKernel
+# (https://github.com/Simple-XX/SimpleKernel).
+#
+# CMakeLists.txt for Simple-XX/SimpleKernel.
+
+ADD_LIBRARY (8259a INTERFACE)
+
+TARGET_INCLUDE_DIRECTORIES (8259a INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
+
+TARGET_SOURCES (8259a INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/8259a.cpp)
diff --git a/src/driver/8259a/README.md b/src/driver/8259a/README.md
new file mode 100644
index 00000000..2881a2af
--- /dev/null
+++ b/src/driver/8259a/README.md
@@ -0,0 +1,3 @@
+# 8259a
+
+x86_64 使用的中断控制器
diff --git a/src/driver/8259a/include/8259a.h b/src/driver/8259a/include/8259a.h
new file mode 100644
index 00000000..1d3cd130
--- /dev/null
+++ b/src/driver/8259a/include/8259a.h
@@ -0,0 +1,47 @@
+
+/**
+ * @file 8259a.h
+ * @brief 8259a 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_DRIVER_8259A_INCLUDE_8259A_H_
+#define SIMPLEKERNEL_SRC_KERNEL_DRIVER_8259A_INCLUDE_8259A_H_
+
+#include <cstdint>
+
+/**
+ * @brief 8259A 中断控制器驱动
+ */
+class PIC8259A {
+ public:
+  /**
+   * 构造函数
+   * @param dev_addr 设备地址
+   */
+  explicit PIC8259A(uint64_t dev_addr);
+
+  /// @name 默认构造/析构函数
+  /// @{
+  PIC8259A() = delete;
+  PIC8259A(const PIC8259A& na16550a) = delete;
+  PIC8259A(PIC8259A&& na16550a) = delete;
+  auto operator=(const PIC8259A& na16550a) -> PIC8259A& = delete;
+  auto operator=(PIC8259A&& na16550a) -> PIC8259A& = delete;
+  ~PIC8259A() = default;
+  /// @}
+
+ private:
+  uint64_t base_addr_ = 0;
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_DRIVER_8259A_INCLUDE_8259A_H_ */
diff --git a/src/driver/CMakeLists.txt b/src/driver/CMakeLists.txt
index 43025c25..52ab8925 100644
--- a/src/driver/CMakeLists.txt
+++ b/src/driver/CMakeLists.txt
@@ -12,14 +12,23 @@ TARGET_SOURCES (driver INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/driver.cpp)
 
 TARGET_LINK_LIBRARIES (
     driver
-    INTERFACE $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},riscv64>:ns16550a>
-              $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},aarch64>:pl011>
-              $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},x86_64>:acpi>)
+    INTERFACE $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},riscv64>:
+              ns16550a
+              plic>
+              $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},aarch64>:
+              pl011
+              gic>
+              $<$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},x86_64>:
+              8259a
+              apic>)
 
 IF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "riscv64")
     ADD_SUBDIRECTORY (ns16550a)
+    ADD_SUBDIRECTORY (plic)
 ELSEIF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "aarch64")
     ADD_SUBDIRECTORY (pl011)
+    ADD_SUBDIRECTORY (gic)
 ELSEIF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
-    ADD_SUBDIRECTORY (acpi)
+    ADD_SUBDIRECTORY (8259a)
+    ADD_SUBDIRECTORY (apic)
 ENDIF()
diff --git a/src/driver/apic/CMakeLists.txt b/src/driver/apic/CMakeLists.txt
new file mode 100644
index 00000000..c6ad4b70
--- /dev/null
+++ b/src/driver/apic/CMakeLists.txt
@@ -0,0 +1,10 @@
+# This file is a part of Simple-XX/SimpleKernel
+# (https://github.com/Simple-XX/SimpleKernel).
+#
+# CMakeLists.txt for Simple-XX/SimpleKernel.
+
+ADD_LIBRARY (apic INTERFACE)
+
+TARGET_INCLUDE_DIRECTORIES (apic INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
+
+TARGET_SOURCES (apic INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/apic.cpp)
diff --git a/src/driver/apic/README.md b/src/driver/apic/README.md
new file mode 100644
index 00000000..9f2a50ba
--- /dev/null
+++ b/src/driver/apic/README.md
@@ -0,0 +1,3 @@
+# apic
+
+x86_64 使用的高级中断控制器
diff --git a/src/driver/apic/apic.cpp b/src/driver/apic/apic.cpp
new file mode 100644
index 00000000..ea826869
--- /dev/null
+++ b/src/driver/apic/apic.cpp
@@ -0,0 +1,21 @@
+
+/**
+ * @file apic.h
+ * @brief apic 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "apic.h"
+
+#include "io.hpp"
+
+Apic::Apic(uint64_t dev_addr) : base_addr_(dev_addr) {}
diff --git a/src/driver/apic/include/apic.h b/src/driver/apic/include/apic.h
new file mode 100644
index 00000000..d807c31f
--- /dev/null
+++ b/src/driver/apic/include/apic.h
@@ -0,0 +1,47 @@
+
+/**
+ * @file apic.h
+ * @brief apic 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_DRIVER_APIC_INCLUDE_APIC_H_
+#define SIMPLEKERNEL_SRC_KERNEL_DRIVER_APIC_INCLUDE_APIC_H_
+
+#include <cstdint>
+
+/**
+ * @brief APIC 高级中断控制器驱动
+ */
+class Apic {
+ public:
+  /**
+   * 构造函数
+   * @param dev_addr 设备地址
+   */
+  explicit Apic(uint64_t dev_addr);
+
+  /// @name 默认构造/析构函数
+  /// @{
+  Apic() = delete;
+  Apic(const Apic& na16550a) = delete;
+  Apic(Apic&& na16550a) = delete;
+  auto operator=(const Apic& na16550a) -> Apic& = delete;
+  auto operator=(Apic&& na16550a) -> Apic& = delete;
+  ~Apic() = default;
+  /// @}
+
+ private:
+  uint64_t base_addr_ = 0;
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_DRIVER_APIC_INCLUDE_APIC_H_ */
diff --git a/src/driver/gic/CMakeLists.txt b/src/driver/gic/CMakeLists.txt
new file mode 100644
index 00000000..b54034b2
--- /dev/null
+++ b/src/driver/gic/CMakeLists.txt
@@ -0,0 +1,10 @@
+# This file is a part of Simple-XX/SimpleKernel
+# (https://github.com/Simple-XX/SimpleKernel).
+#
+# CMakeLists.txt for Simple-XX/SimpleKernel.
+
+ADD_LIBRARY (gic INTERFACE)
+
+TARGET_INCLUDE_DIRECTORIES (gic INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
+
+TARGET_SOURCES (gic INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/gic.cpp)
diff --git a/src/driver/gic/README.md b/src/driver/gic/README.md
new file mode 100644
index 00000000..e73259ab
--- /dev/null
+++ b/src/driver/gic/README.md
@@ -0,0 +1,31 @@
+# gic
+
+aarch64 使用的中断控制器
+
+https://developer.arm.com/documentation/100095/0003/Generic-Interrupt-Controller-CPU-Interface
+
+https://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/arm%2Cgic-v3.txt
+
+https://github.com/qemu/qemu/blob/master/hw/arm/virt.c
+
+```
+intc@8000000 {
+		phandle = <0x8005>;
+		reg = <0x00 0x8000000 0x00 0x10000 0x00 0x80a0000 0x00 0xf60000>;
+		#redistributor-regions = <0x01>;
+		compatible = "arm,gic-v3";
+		ranges;
+		#size-cells = <0x02>;
+		#address-cells = <0x02>;
+		interrupt-controller;
+		#interrupt-cells = <0x03>;
+
+		its@8080000 {
+			phandle = <0x8006>;
+			reg = <0x00 0x8080000 0x00 0x20000>;
+			#msi-cells = <0x01>;
+			msi-controller;
+			compatible = "arm,gic-v3-its";
+		};
+	};
+```
diff --git a/src/driver/gic/gic.cpp b/src/driver/gic/gic.cpp
new file mode 100644
index 00000000..834e310b
--- /dev/null
+++ b/src/driver/gic/gic.cpp
@@ -0,0 +1,180 @@
+
+/**
+ * @file gic.h
+ * @brief gic 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "gic.h"
+
+#include "io.hpp"
+#include "kernel_log.hpp"
+
+Gic::Gic(uint64_t gicd_base_addr, uint64_t gicr_base_addr)
+    : gicd_(gicd_base_addr), gicr_(gicr_base_addr) {
+  cpu_io::ICC_IGRPEN1_EL1::Enable::Clear();
+  cpu_io::ICC_PMR_EL1::Priority::Set();
+
+  gicd_.EnableGrp1NS();
+
+  klog::Info("Gic init.\n");
+}
+
+void Gic::SPI(uint32_t intid) const { gicd_.SetupSPI(intid); }
+
+void Gic::PPI(uint32_t intid, uint32_t cpuid) const {
+  gicr_.SetupPPI(intid, cpuid);
+}
+
+Gic::Gicd::Gicd(uint64_t base_addr) : base_addr_(base_addr) {
+  if (base_addr_ == 0) {
+    klog::Err("GICD base address is invalid [0x%X]\n", base_addr_);
+    throw;
+  }
+  // 将 GICD_CTLR 清零
+  Write(kCTLR, 0);
+
+  // 读取 ITLinesNumber 数量
+  auto it_lines_number = Read(kTYPER) & kTYPER_ITLinesNumberMask;
+
+  klog::Info("it_lines_number %d\n", it_lines_number);
+
+  // 设置中断为 Non-secure Group 1
+  for (uint32_t i = 0; i < it_lines_number; i++) {
+    Write(IGROUPRn(i), UINT32_MAX);
+  }
+}
+
+void Gic::Gicd::Enable(uint32_t intid) const {
+  auto is = Read(ISENABLERn(intid / kISENABLERn_SIZE));
+  is |= 1 << (intid % kISENABLERn_SIZE);
+  Write(ISENABLERn(intid / kISENABLERn_SIZE), is);
+}
+
+void Gic::Gicd::Disable(uint32_t intid) const {
+  auto ic = Read(ICENABLERn(intid / kICENABLERn_SIZE));
+  ic |= 1 << (intid % kICENABLERn_SIZE);
+  Write(ICENABLERn(intid / kICENABLERn_SIZE), ic);
+}
+
+void Gic::Gicd::Clear(uint32_t intid) const {
+  auto ic = Read(ICPENDRn(intid / kICPENDRn_SIZE));
+  ic |= 1 << (intid % kICPENDRn_SIZE);
+  Write(ICPENDRn(intid / kICPENDRn_SIZE), ic);
+}
+
+auto Gic::Gicd::IsEnable(uint32_t intid) const -> bool {
+  auto is = Read(ISENABLERn(intid / kISENABLERn_SIZE));
+  return is & (1 << (intid % kISENABLERn_SIZE));
+}
+
+void Gic::Gicd::SetPrio(uint32_t intid, uint32_t prio) const {
+  auto shift = (intid % kIPRIORITYRn_SIZE) * kIPRIORITYRn_BITS;
+  auto ip = Read(IPRIORITYRn(intid / kIPRIORITYRn_SIZE));
+  ip &= ~(kIPRIORITYRn_BITS_MASK << shift);
+  ip |= prio << shift;
+  Write(IPRIORITYRn(intid / kIPRIORITYRn_SIZE), ip);
+}
+
+void Gic::Gicd::SetConfig(uint32_t intid, uint32_t config) const {
+  auto shift = (intid % kICFGRn_SIZE) * kICFGRn_BITS;
+  auto ic = Read(ICFGRn(intid / kICFGRn_SIZE));
+  ic &= ~(kICFGRn_BITS_MASK << shift);
+  ic |= config << shift;
+  Write(ICFGRn(intid / kICFGRn_SIZE), ic);
+}
+
+void Gic::Gicd::SetTarget(uint32_t intid, uint32_t cpuid) const {
+  auto target = Read(ITARGETSRn(intid / kITARGETSRn_SIZE));
+  target &=
+      ~(kICFGRn_BITS_MASK << ((intid % kITARGETSRn_SIZE) * kITARGETSRn_BITS));
+  Write(ITARGETSRn(intid / kITARGETSRn_SIZE),
+        target |
+            ((1 << cpuid) << ((intid % kITARGETSRn_SIZE) * kITARGETSRn_BITS)));
+}
+
+void Gic::Gicd::SetupSPI(uint32_t intid) const {
+  // 电平触发
+  SetConfig(intid, kICFGRn_LevelSensitive);
+
+  // 优先级设定
+  SetPrio(intid, 0);
+
+  // 设置所有中断由 cpu0 处理
+  SetTarget(intid, 0);
+  // 清除中断请求
+  Clear(intid);
+  // 使能中断
+  Enable(intid);
+}
+
+Gic::Gicr::Gicr(uint64_t base_addr) : base_addr_(base_addr) {
+  if (base_addr_ == 0) {
+    klog::Err("GICR base address is invalid [0x%X]\n", base_addr_);
+    throw;
+  }
+
+  auto cpuid = cpu_io::GetCurrentCoreId();
+
+  // 将 GICR_CTLR 清零
+  Write(cpuid, kCTLR, 0);
+
+  // The System register interface for the current Security state is enabled.
+  cpu_io::ICC_SRE_EL1::SRE::Set();
+
+  // 允许 Non-secure Group 1 中断
+  Write(cpuid, kIGROUPR0, kIGROUPR0_Set);
+  Write(cpuid, kIGRPMODR0, kIGRPMODR0_Clear);
+
+  // 唤醒 Redistributor
+  // @see
+  // https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-WAKER--Redistributor-Wake-Register?lang=en
+  auto waker = Read(cpuid, kWAKER);
+  // Clear the ProcessorSleep bit
+  Write(cpuid, kWAKER, waker & ~kWAKER_ProcessorSleepMASK);
+  // 等待唤醒完成
+  while (Read(cpuid, kWAKER) & kWAKER_ChildrenAsleepMASK) {
+    ;
+  }
+}
+
+void Gic::Gicr::Enable(uint32_t intid, uint32_t cpuid) const {
+  auto is = Read(cpuid, kISENABLER0);
+  is |= 1 << (intid % kISENABLER0_SIZE);
+  Write(cpuid, kISENABLER0, is);
+}
+
+void Gic::Gicr::Disable(uint32_t intid, uint32_t cpuid) const {
+  auto ic = Read(cpuid, kICENABLER0);
+  ic |= 1 << (intid % kICENABLER0_SIZE);
+  Write(cpuid, kICENABLER0, ic);
+}
+
+void Gic::Gicr::Clear(uint32_t intid, uint32_t cpuid) const {
+  auto ic = Read(cpuid, kICPENDR0);
+  ic |= 1 << (intid % kICPENDR0_SIZE);
+  Write(cpuid, kICPENDR0, ic);
+}
+
+void Gic::Gicr::SetPrio(uint32_t intid, uint32_t cpuid, uint32_t prio) const {
+  auto shift = (intid % kIPRIORITYRn_SIZE) * kIPRIORITYRn_BITS;
+  auto ip = Read(cpuid, IPRIORITYRn(intid / kIPRIORITYRn_SIZE));
+  ip &= ~(kIPRIORITYRn_BITS_MASK << shift);
+  ip |= prio << shift;
+  Write(cpuid, IPRIORITYRn(intid / kIPRIORITYRn_SIZE), ip);
+}
+
+void Gic::Gicr::SetupPPI(uint32_t intid, uint32_t cpuid) const {
+  SetPrio(intid, cpuid, 0);
+  Clear(intid, cpuid);
+  Enable(intid, cpuid);
+}
diff --git a/src/driver/gic/include/gic.h b/src/driver/gic/include/gic.h
new file mode 100644
index 00000000..4db0d8ca
--- /dev/null
+++ b/src/driver/gic/include/gic.h
@@ -0,0 +1,589 @@
+
+/**
+ * @file gic.h
+ * @brief gic 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_DRIVER_GIC_INCLUDE_GIC_H_
+#define SIMPLEKERNEL_SRC_KERNEL_DRIVER_GIC_INCLUDE_GIC_H_
+
+#include <array>
+#include <cstdint>
+
+#include "io.hpp"
+#include "kernel_log.hpp"
+#include "per_cpu.hpp"
+
+/**
+ * @brief gic 中断控制器驱动
+ * @see
+ * https://developer.arm.com/documentation/100095/0003/Generic-Interrupt-Controller-CPU-Interface/GIC-programmers-model/CPU-interface-memory-mapped-register-descriptions
+ */
+class Gic {
+ public:
+  static constexpr const char* kCompatibleName = "arm,gic-v3";
+
+  static constexpr const size_t kSGIBase = 0;
+  static constexpr const size_t kSGICount = 16;
+  static constexpr const size_t kPPIBase = 16;
+  static constexpr const size_t kPPICount = 16;
+  static constexpr const size_t kSPIBase = 32;
+  static constexpr const size_t kSPICount = 988;
+
+  class Gicd {
+   public:
+    /// @see
+    /// https://developer.arm.com/documentation/101206/0003/Programmers-model/Distributor-registers--GICD-GICDA--summary
+    /// GICD Register offsets
+    /// Configuration dependent	Distributor Control Register, RW
+    static constexpr const uint32_t kCTLR = 0x0000;
+    static constexpr const uint32_t kCTLR_EnableGrp1NS = 0x2;
+    /**
+     * @brief GICD_CTLR, Distributor Control Register
+     * @see
+     * https://developer.arm.com/documentation/101206/0003/Programmers-model/Distributor-registers--GICD-GICDA--summary/GICD-CTLR--Distributor-Control-Register?lang=en
+     */
+    struct GICD_CTLR {
+      // [31] Register Write Pending:
+      uint32_t rwp : 1;
+      uint32_t reserved1 : 23;
+      // [7]	E1NWF	Enable 1 of N Wakeup Functionality
+      uint32_t e1nwf : 1;
+      // [6]	DS	Disable Security
+      uint32_t ds : 1;
+      // [5]	ARE_NS	Affinity Routing Enable, Non-secure state
+      uint32_t are_ns : 1;
+      // [4]	ARE_S	Affinity Routing Enable, Secure state
+      uint32_t are_s : 1;
+      uint32_t reserved0 : 1;
+      // [2]	EnableGrp1S	Enable Secure Group 1 interrupts
+      uint32_t enable_grp1_s : 1;
+      // [1]	EnableGrp1NS	Enable Non-secure Group 1 interrupts
+      uint32_t enable_grp1_ns : 1;
+      // [0]	EnableGrp0	Enable Group 0 interrupts
+      uint32_t enable_grp0 : 1;
+    };
+
+    /// Configuration dependent	Interrupt Controller Type Register, RO
+    static constexpr const uint32_t kTYPER = 0x0004;
+    static constexpr const uint32_t kTYPER_ITLinesNumberMask = 0x1F;
+    /**
+     * @brief GICD_TYPER, Interrupt Controller Type Register
+     * @see
+     * https://developer.arm.com/documentation/101206/0003/Programmers-model/Distributor-registers--GICD-GICDA--summary/GICD-TYPER--Interrupt-Controller-Type-Register?lang=en
+     */
+    struct GICD_TYPER {
+      // [31:26]	Reserved, returns 0b000000
+      uint32_t reserved1 : 6;
+      // [25]	No1N	1 of N SPI
+      uint32_t no1n : 1;
+      // [24]	A3V	Affinity level 3 values.
+      uint32_t a3v : 1;
+      // [23:19]	IDbits	Interrupt identifier bits
+      uint32_t idbits : 5;
+      // [18]	DVIS	Direct virtual LPI injection support
+      uint32_t dvis : 1;
+      // [17]	LPIS	Indicates whether the implementation supports LPIs.
+      uint32_t lpis : 1;
+      // [16]	MBIS	Message-based interrupt support
+      uint32_t mbis : 1;
+      // [15:11]	num_LPIs	Returns 0b00000 because
+      // GICD_TYPER.IDbits indicates the number of LPIs that the GIC supports.
+      uint32_t num_lpis : 5;
+      // [10]	SecurityExtn	Security state support.
+      uint32_t security_extn : 1;
+      // [9:8]	-	Reserved, returns 0b00000
+      uint32_t reserved0 : 2;
+      // [7:5]	CPUNumber	Returns 0b000 because GICD_CTLR.ARE==1 (ARE_NS &
+      // ARE_S).
+      uint32_t cpu_number : 3;
+      // [4:0]	ITLinesNumber	Returns the maximum SPI INTID that this
+      // GIC-600AE implementation supports, and is given by 32×(ITLinesNumber +
+      // 1) − 1.
+      uint32_t it_lines_number : 5;
+    };
+
+    /// Configuration dependent	Distributor Implementer Identification Register,
+    /// RO
+    static constexpr const uint32_t kIIDR = 0x0008;
+    /**
+     * @brief GICD_IIDR, Distributor Implementer Identification Register
+     * @see
+     * https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-IIDR--Distributor-Implementer-Identification-Register?lang=en
+     */
+    struct GICD_IIDR {
+      // [31:24] Product Identifier.
+      uint32_t product_id : 8;
+      // [23:20] Reserved, RES0.
+      uint32_t reserved0 : 4;
+      // [19:16] Variant number. Typically, this field is used to distinguish
+      // product variants, or major revisions of a product.
+      uint32_t variant : 4;
+      // [15:12] Revision number. Typically, this field is used to distinguish
+      // minor revisions of a product.
+      uint32_t revision : 4;
+      // [11:0] Contains the JEP106 manufacturer's identification code of the
+      // designer of the Distributor.
+      uint32_t implementer : 12;
+    };
+
+    /// Function Control Register, RW
+    static constexpr const uint32_t kFCTLR = 0x0020;
+    /// Tie-off dependentb	Secure Access Control register, RW
+    static constexpr const uint32_t kSAC = 0x0024;
+    /// Non-secure SPI Set Register, WO
+    static constexpr const uint32_t kSETSPI_NSR = 0x0040;
+    /// Non-secure SPI Clear Register, WO
+    static constexpr const uint32_t kCLRSPI_NSR = 0x0048;
+    /// Secure SPI Set Register, WO
+    static constexpr const uint32_t kSETSPI_SR = 0x0050;
+    /// Secure SPI Clear Register, WO
+    static constexpr const uint32_t kCLRSPI_SR = 0x0058;
+
+    /// Interrupt Group Registers, n = 0-31, but n=0 is Reserved
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-IGROUPR-n---Interrupt-Group-Registers?lang=en
+    static constexpr const uint32_t kIGROUPRn = 0x0080;
+    __always_inline auto IGROUPRn(uint64_t n) const -> uint64_t {
+      return kIGROUPRn + n * 4;
+    }
+
+    /// Interrupt Set-Enable Registers, n = 0-31, but n=0 is Reserved
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-ISENABLER-n---Interrupt-Set-Enable-Registers?lang=en
+    static constexpr const uint32_t kISENABLERn = 0x0100;
+    static constexpr const uint32_t kISENABLERn_SIZE = 32;
+    __always_inline auto ISENABLERn(uint64_t n) const -> uint64_t {
+      return kISENABLERn + n * 4;
+    }
+
+    /// Interrupt Clear-Enable Registers, n = 0-31, but n=0 is Reserved
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-ICENABLER-n---Interrupt-Clear-Enable-Registers?lang=en
+    static constexpr const uint32_t kICENABLERn = 0x0180;
+    static constexpr const uint32_t kICENABLERn_SIZE = 32;
+    __always_inline auto ICENABLERn(uint64_t n) const -> uint64_t {
+      return kICENABLERn + n * 4;
+    }
+
+    /// Interrupt Set-Pending Registers, n = 0-31, but n=0 is Reserved
+    static constexpr const uint32_t kISPENDRn = 0x0200;
+
+    /// Interrupt Clear-Pending Registers, n = 0-31, but n=0 is Reserved
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-ICPENDR-n---Interrupt-Clear-Pending-Registers?lang=en
+    static constexpr const uint32_t kICPENDRn = 0x0280;
+    static constexpr const uint32_t kICPENDRn_SIZE = 32;
+    __always_inline auto ICPENDRn(uint64_t n) const -> uint64_t {
+      return kICPENDRn + n * 4;
+    }
+
+    /// Interrupt Set-Active Registers, n = 0-31, but n=0 is Reserved
+    static constexpr const uint32_t kISACTIVERn = 0x0300;
+    /// Interrupt Clear-Active Registers, n = 0-31, but n=0 is Reserved
+    static constexpr const uint32_t kICACTIVERn = 0x0380;
+
+    /// Interrupt Priority Registers, n = 0-255, but n=0-7 are Reserved when
+    /// affinity routing is enabled
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-IPRIORITYR-n---Interrupt-Priority-Registers?lang=en
+    static constexpr const uint32_t kIPRIORITYRn = 0x0400;
+    static constexpr const uint32_t kIPRIORITYRn_SIZE = 4;
+    static constexpr const uint32_t kIPRIORITYRn_BITS = 8;
+    static constexpr const uint32_t kIPRIORITYRn_BITS_MASK = 0xFF;
+    __always_inline auto IPRIORITYRn(uint64_t n) const -> uint64_t {
+      return kIPRIORITYRn + n * 4;
+    }
+
+    /// Interrupt Processor Targets Registers, n = 0 - 254
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-ITARGETSR-n---Interrupt-Processor-Targets-Registers?lang=en
+    static constexpr const uint32_t kITARGETSRn = 0x0800;
+    static constexpr const uint32_t kITARGETSRn_SIZE = 4;
+    static constexpr const uint32_t kITARGETSRn_BITS = 8;
+    static constexpr const uint32_t kITARGETSRn_BITS_MASK = 0xFF;
+    __always_inline auto ITARGETSRn(uint64_t n) const -> uint64_t {
+      return kITARGETSRn + n * 4;
+    }
+
+    /// Interrupt Configuration Registers, n = 0-63, but n=0-1 are Reserved
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICD-ICFGR-n---Interrupt-Configuration-Registers?lang=en
+    static constexpr const uint32_t kICFGRn = 0x0C00;
+    static constexpr const uint32_t kICFGRn_SIZE = 16;
+    static constexpr const uint32_t kICFGRn_BITS = 2;
+    static constexpr const uint32_t kICFGRn_BITS_MASK = 0x3;
+    static constexpr const uint32_t kICFGRn_LevelSensitive = 0;
+    static constexpr const uint32_t kICFGRn_EdgeTriggered = 1;
+    __always_inline auto ICFGRn(uint64_t n) const -> uint64_t {
+      return kICFGRn + n * 4;
+    }
+
+    /// Interrupt Group Modifier Registers, n = 0-31, but n=0 is Reserved. If
+    /// GICD_CTLR.DS == 1, then this register is RAZ/WI.
+    static constexpr const uint32_t kIGRPMODRn = 0x0D00;
+    /// Non-secure Access Control Registers, n = 0-63, but n=0-1 are Reserved
+    /// when affinity routing is enabled
+    static constexpr const uint32_t kNSACRn = 0x0E00;
+    /// Interrupt Routing Registers, n = 0-991, but n=0-31 are Reserved when
+    /// affinity routing is enabled.
+    static constexpr const uint32_t kIROUTERn = 0x6000;
+    /// P-Channel dependent	Chip Status Register, RW
+    static constexpr const uint32_t kCHIPSR = 0xC000;
+    /// Default Chip Register, RW
+    static constexpr const uint32_t kDCHIPR = 0xC004;
+    /// Chip Registers, n = 0-15. Reserved in single-chip configurations.
+    static constexpr const uint32_t kCHIPRn = 0xC008;
+    /// Interrupt Class Registers, n = 0-63, but n=0-1 are Reserved
+    static constexpr const uint32_t kICLARn = 0xE000;
+    /// Interrupt Clear Error Registers, n = 0-31, but n=0 is Reserved
+    static constexpr const uint32_t kICERRRn = 0xE100;
+    /// Configuration dependent	Configuration ID Register, RO
+    static constexpr const uint64_t kCFGID = 0xF000;
+    /// Peripheral ID4 register	, RO
+    static constexpr const uint32_t kPIDR4 = 0xFFD0;
+    /// Peripheral ID 5 Register, RO
+    static constexpr const uint32_t kPIDR5 = 0xFFD4;
+    /// Peripheral ID 6 Register, RO
+    static constexpr const uint32_t kPIDR6 = 0xFFD8;
+    /// Peripheral ID 7 Register, RO
+    static constexpr const uint32_t kPIDR7 = 0xFFDC;
+    /// Peripheral ID0 register, RO
+    static constexpr const uint32_t kPIDR0 = 0xFFE0;
+    /// Peripheral ID1 register, RO
+    static constexpr const uint32_t kPIDR1 = 0xFFE4;
+    /// Peripheral ID2 register, RO
+    static constexpr const uint32_t kPIDR2 = 0xFFE8;
+    /// Peripheral ID3 register, RO
+    static constexpr const uint32_t kPIDR3 = 0xFFEC;
+    /// Component ID 0 Register, RO
+    static constexpr const uint32_t kCIDR0 = 0xFFF0;
+    /// Component ID 1 Register, RO
+    static constexpr const uint32_t kCIDR1 = 0xFFF4;
+    /// Component ID 2 Register, RO
+    static constexpr const uint32_t kCIDR2 = 0xFFF8;
+    /// Component ID 3 Register, RO
+    static constexpr const uint32_t kCIDR3 = 0xFFFC;
+
+    /**
+     * 构造函数
+     * @param dev_addr 设备地址
+     */
+    explicit Gicd(uint64_t base_addr);
+
+    /// @name 默认构造/析构函数
+    /// @{
+    Gicd() = default;
+    Gicd(const Gicd& na16550a) = delete;
+    Gicd(Gicd&& na16550a) = delete;
+    auto operator=(const Gicd& na16550a) -> Gicd& = delete;
+    auto operator=(Gicd&& na16550a) -> Gicd& = default;
+    ~Gicd() = default;
+    /// @}
+
+    /**
+     * 允许从 Distributor 转发到 redistributor
+     * @param intid 中断号
+     */
+    void Enable(uint32_t intid) const;
+
+    /**
+     * 允许 no-sec group1 中断
+     */
+    void EnableGrp1NS() const {
+      Write(kCTLR, kCTLR_EnableGrp1NS);
+      cpu_io::ICC_IGRPEN1_EL1::Enable::Set();
+    }
+
+    /**
+     * 禁止从 Distributor 转发到 redistributor
+     * @param intid 中断号
+     */
+    void Disable(uint32_t intid) const;
+
+    /**
+     * 清除 intid 的中断
+     * @param intid 中断号
+     */
+    void Clear(uint32_t intid) const;
+
+    /**
+     * 判断 intid 中断是否使能
+     * @param intid 中断号
+     * @return true 允许
+     */
+    auto IsEnable(uint32_t intid) const -> bool;
+
+    /**
+     * 设置 intid 的优先级
+     * @param intid 中断号
+     * @param prio 优先级
+     */
+    void SetPrio(uint32_t intid, uint32_t prio) const;
+
+    /**
+     * 设置 intid 的属性
+     * @param intid 中断号
+     * @param config 属性
+     */
+    void SetConfig(uint32_t intid, uint32_t config) const;
+
+    /**
+     * 设置 intid 的由指定 cpu 处理
+     * @param intid 中断号
+     * @param cpuid cpu 编号
+     */
+    void SetTarget(uint32_t intid, uint32_t cpuid) const;
+
+    /**
+     * 设置指定 SPI 中断
+     * SPI: shared peripheral interrupt,
+     * 共享外设中断，该中断来源于外设，但是该中断可以对所有的 core 有效
+     * @param intid 中断号
+     */
+    void SetupSPI(uint32_t intid) const;
+
+   private:
+    uint64_t base_addr_ = 0;
+
+    __always_inline auto Read(uint32_t off) const -> uint32_t {
+      return io::In<uint32_t>(base_addr_ + off);
+    }
+
+    __always_inline void Write(uint32_t off, uint32_t val) const {
+      io::Out<uint32_t>(base_addr_ + off, val);
+    }
+  };
+
+  class Gicr {
+   public:
+    /// 每个 GICR 长度 2 * 64 * 1024
+    static constexpr const uint32_t kSTRIDE = 0x20000;
+
+    /// Redistributor Control Register, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-CTLR--Redistributor-Control-Register?lang=en
+    static constexpr const uint32_t kCTLR = 0x0000;
+    /// Redistributor Implementation Identification Register, RO
+    static constexpr const uint32_t kIIDR = 0x0004;
+    /// Redistributor Type Register, RO
+    static constexpr const uint32_t kTYPER = 0x0008;
+
+    /// Power Management Control Register, RW1
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-WAKER--Redistributor-Wake-Register?lang=en
+    static constexpr const uint32_t kWAKER = 0x0014;
+    static constexpr const uint32_t kWAKER_ProcessorSleepMASK = 2;
+    static constexpr const uint32_t kWAKER_ChildrenAsleepMASK = 4;
+
+    /// Function Control Register, RW
+    static constexpr const uint32_t kFCTLR = 0x0020;
+    /// Power Register, RW
+    static constexpr const uint32_t kPWRR = 0x0024;
+    /// Class Register, RW
+    static constexpr const uint32_t kCLASSR = 0x0028;
+    /// Redistributor Properties Base Address Register, RW
+    static constexpr const uint32_t kPROPBASER = 0x0070;
+    /// Redistributor LPI Pending Table Base Address Register, RW
+    static constexpr const uint32_t kPENDBASER = 0x0078;
+    /// Peripheral ID 4 Register, RO
+    static constexpr const uint32_t kPIDR4 = 0xFFD0;
+    /// Peripheral ID 5 Register, RO
+    static constexpr const uint32_t kPIDR5 = 0xFFD4;
+    /// Peripheral ID 6 Register, RO
+    static constexpr const uint32_t kPIDR6 = 0xFFD8;
+    /// Peripheral ID 7 Register, RO
+    static constexpr const uint32_t kPIDR7 = 0xFFDC;
+    /// Peripheral ID 0 Register, RO
+    static constexpr const uint32_t kPIDR0 = 0xFFE0;
+    /// Peripheral ID 1 Register, RO
+    static constexpr const uint32_t kPIDR1 = 0xFFE4;
+    /// Peripheral ID 2 Register, RO
+    static constexpr const uint32_t kPIDR2 = 0xFFE8;
+    /// Peripheral ID 3 Register, RO
+    static constexpr const uint32_t kPIDR3 = 0xFFEC;
+    /// Component ID 0 Register, RO
+    static constexpr const uint32_t kCIDR0 = 0xFFF0;
+    /// Component ID 1 Register, RO
+    static constexpr const uint32_t kCIDR1 = 0xFFF4;
+    /// Component ID 2 Register, RO
+    static constexpr const uint32_t kCIDR2 = 0xFFF8;
+    /// Component ID 3 Register, RO
+    static constexpr const uint32_t kCIDR3 = 0xFFFC;
+
+    /// SGI 基地址 64 * 1024
+    static constexpr const uint32_t kSGI_BASE = 0x10000;
+
+    /// Interrupt Group Register, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-IGROUPR0--Interrupt-Group-Register-0?lang=en
+    static constexpr const uint32_t kIGROUPR0 = kSGI_BASE + 0x0080;
+    static constexpr const uint32_t kIGROUPR0_Clear = 0;
+    static constexpr const uint32_t kIGROUPR0_Set = UINT32_MAX;
+
+    /// Interrupt Set-Enable Register, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-ISENABLER0--Interrupt-Set-Enable-Register-0?lang=en
+    static constexpr const uint32_t kISENABLER0 = kSGI_BASE + 0x0100;
+    static constexpr const uint32_t kISENABLER0_SIZE = 32;
+
+    /// Interrupt Clear-Enable Register, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-ICENABLER0--Interrupt-Clear-Enable-Register-0?lang=en
+    static constexpr const uint32_t kICENABLER0 = kSGI_BASE + 0x0180;
+    static constexpr const uint32_t kICENABLER0_SIZE = 32;
+
+    /// Interrupt Set-Pending Register, RW
+    static constexpr const uint32_t kISPENDR0 = kSGI_BASE + 0x0200;
+
+    /// Peripheral Clear Pending Register, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-ICPENDR0--Interrupt-Clear-Pending-Register-0?lang=en
+    static constexpr const uint32_t kICPENDR0 = kSGI_BASE + 0x0280;
+    static constexpr const uint32_t kICPENDR0_SIZE = 32;
+
+    /// Interrupt Set-Active Register, RW
+    static constexpr const uint32_t kISACTIVER0 = kSGI_BASE + 0x0300;
+    /// Interrupt Clear-Active Register, RW
+    static constexpr const uint32_t kICACTIVER0 = kSGI_BASE + 0x0380;
+    /// Interrupt Priority Registers, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-IPRIORITYR-n---Interrupt-Priority-Registers?lang=en
+    static constexpr const uint32_t kIPRIORITYRn = kSGI_BASE + 0x0400;
+    static constexpr const uint32_t kIPRIORITYRn_SIZE = 4;
+    static constexpr const uint32_t kIPRIORITYRn_BITS = 8;
+    static constexpr const uint32_t kIPRIORITYRn_BITS_MASK = 0xFF;
+    __always_inline auto IPRIORITYRn(uint64_t n) const -> uint64_t {
+      return kIPRIORITYRn + n * 4;
+    }
+
+    /// Interrupt Configuration Registers, RW
+    static constexpr const uint32_t kICFGRn = 0x0C00;
+
+    /// Interrupt Group Modifier Register, RW
+    /// @see
+    /// https://developer.arm.com/documentation/ddi0601/2024-12/External-Registers/GICR-IGRPMODR0--Interrupt-Group-Modifier-Register-0?lang=en
+    static constexpr const uint32_t kIGRPMODR0 = 0x0D00;
+    // kIGRPMODR0 kIGROUPR0 Definition
+    // 0b0	       0b0       Secure Group 0	G0S
+    // 0b0	       0b1	     Non-secure Group 1	G1NS
+    // 0b1	       0b0       Secure Group 1	G1S
+    static constexpr const uint32_t kIGRPMODR0_Clear = 0;
+    static constexpr const uint32_t kIGRPMODR0_Set = UINT32_MAX;
+
+    /// Non-secure Access Control Register, RW
+    static constexpr const uint32_t kNSACR = 0x0E00;
+    /// Miscellaneous Status Register, RO
+    static constexpr const uint32_t kMISCSTATUSR = 0xC000;
+    /// Interrupt Error Valid Register, RW
+    static constexpr const uint32_t kIERRVR = 0xC008;
+    /// SGI Default Register, RW
+    static constexpr const uint32_t kSGIDR = 0xC010;
+    /// Configuration ID0 Register, RO
+    static constexpr const uint32_t kCFGID0 = 0xF000;
+    /// Configuration ID1 Register, RO
+    static constexpr const uint32_t kCFGID1 = 0xF004;
+
+    /**
+     * 构造函数
+     * @param dev_addr 设备地址
+     */
+    explicit Gicr(uint64_t base_addr);
+
+    /// @name 默认构造/析构函数
+    /// @{
+    Gicr() = default;
+    Gicr(const Gicr& na16550a) = delete;
+    Gicr(Gicr&& na16550a) = delete;
+    auto operator=(const Gicr& na16550a) -> Gicr& = delete;
+    auto operator=(Gicr&& na16550a) -> Gicr& = default;
+    ~Gicr() = default;
+    /// @}
+
+    /**
+     * 允许从 redistributor 转发到 CPU interface
+     * @param intid 中断号
+     * @param cpuid cpu 编号
+     */
+    void Enable(uint32_t intid, uint32_t cpuid) const;
+
+    /**
+     * 禁止从 redistributor 转发到 CPU interface
+     * @param intid 中断号
+     * @param cpuid cpu 编号
+     */
+    void Disable(uint32_t intid, uint32_t cpuid) const;
+
+    /**
+     * 清除指定 cpu intid 的中断
+     * @param intid 中断号
+     * @param cpuid cpu 编号
+     */
+    void Clear(uint32_t intid, uint32_t cpuid) const;
+
+    /**
+     * 设置 intid 的优先级
+     * @param intid 中断号
+     * @param cpuid cpu 编号
+     * @param prio 优先级
+     */
+    void SetPrio(uint32_t intid, uint32_t cpuid, uint32_t prio) const;
+
+    /**
+     * 设置指定 PPI 中断
+     * PPI: private peripheral interrupt,
+     * 私有外设中断，该中断来源于外设，但是该中断只对指定的 core 有效
+     * @param intid 中断号
+     * @param cpuid cpu 编号
+     */
+    void SetupPPI(uint32_t intid, uint32_t cpuid) const;
+
+   private:
+    uint64_t base_addr_ = 0;
+
+    __always_inline auto Read(uint32_t cpuid, uint32_t off) const -> uint32_t {
+      return io::In<uint32_t>(base_addr_ + cpuid * kSTRIDE + off);
+    }
+
+    __always_inline void Write(uint32_t cpuid, uint32_t off,
+                               uint32_t val) const {
+      io::Out<uint32_t>(base_addr_ + cpuid * kSTRIDE + off, val);
+    }
+  };
+
+  /**
+   * 构造函数
+   * @param gicd_base_addr gic distributor 地址
+   * @param gicr_base_addr gic redistributor 地址
+   */
+  explicit Gic(uint64_t gicd_base_addr, uint64_t gicr_base_addr);
+
+  /// @name 默认构造/析构函数
+  /// @{
+  Gic() = default;
+  Gic(const Gic& na16550a) = delete;
+  Gic(Gic&& na16550a) = delete;
+  auto operator=(const Gic& na16550a) -> Gic& = delete;
+  auto operator=(Gic&& na16550a) -> Gic& = default;
+  ~Gic() = default;
+  /// @}
+
+  void SPI(uint32_t intid) const;
+  void PPI(uint32_t intid, uint32_t cpuid) const;
+
+ private:
+  Gicd gicd_;
+  Gicr gicr_;
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_DRIVER_GIC_INCLUDE_GIC_H_ */
diff --git a/src/driver/ns16550a/include/ns16550a.h b/src/driver/ns16550a/include/ns16550a.h
index 4640ec9a..0a657f7b 100644
--- a/src/driver/ns16550a/include/ns16550a.h
+++ b/src/driver/ns16550a/include/ns16550a.h
@@ -39,6 +39,18 @@ class Ns16550a {
 
   void PutChar(uint8_t c) const;
 
+  /**
+   * 阻塞式读取一个字符
+   * @return 读取到的字符
+   */
+  [[nodiscard]] auto GetChar() const -> uint8_t;
+
+  /**
+   * 非阻塞式尝试读取一个字符
+   * @return 读取到的字符，如果没有数据则返回 -1
+   */
+  [[nodiscard]] auto TryGetChar() const -> uint8_t;
+
  private:
   /// read mode: Receive holding reg
   static constexpr const uint8_t kRegRHR = 0;
diff --git a/src/driver/ns16550a/ns16550a.cpp b/src/driver/ns16550a/ns16550a.cpp
index 4ff4be1d..315f17b7 100644
--- a/src/driver/ns16550a/ns16550a.cpp
+++ b/src/driver/ns16550a/ns16550a.cpp
@@ -39,3 +39,19 @@ void Ns16550a::PutChar(uint8_t c) const {
   }
   io::Out<uint8_t>(base_addr_ + kRegTHR, c);
 }
+
+auto Ns16550a::GetChar() const -> uint8_t {
+  // 等待直到接收缓冲区有数据 (LSR bit 0 = 1)
+  while ((io::In<uint8_t>(base_addr_ + kRegLSR) & (1 << 0)) == 0) {
+    ;
+  }
+  return io::In<uint8_t>(base_addr_ + kRegRHR);
+}
+
+auto Ns16550a::TryGetChar() const -> uint8_t {
+  // 检查接收缓冲区是否有数据 (LSR bit 0 = 1)
+  if ((io::In<uint8_t>(base_addr_ + kRegLSR) & (1 << 0)) != 0) {
+    return io::In<uint8_t>(base_addr_ + kRegRHR);
+  }
+  return -1;
+}
diff --git a/src/driver/pl011/include/pl011.h b/src/driver/pl011/include/pl011.h
index bd237c7b..d15a0022 100644
--- a/src/driver/pl011/include/pl011.h
+++ b/src/driver/pl011/include/pl011.h
@@ -35,15 +35,16 @@ class Pl011 {
 
   /// @name 默认构造/析构函数
   /// @{
-  Pl011() = delete;
-  Pl011(const Pl011& na16550a) = delete;
-  Pl011(Pl011&& na16550a) = delete;
-  auto operator=(const Pl011& na16550a) -> Pl011& = delete;
-  auto operator=(Pl011&& na16550a) -> Pl011& = delete;
+  Pl011() = default;
+  Pl011(const Pl011& na16550a) = default;
+  Pl011(Pl011&& na16550a) = default;
+  auto operator=(const Pl011& na16550a) -> Pl011& = default;
+  auto operator=(Pl011&& na16550a) -> Pl011& = default;
   ~Pl011() = default;
   /// @}
 
   void PutChar(uint8_t c);
+  auto GetChar() -> uint8_t;
 
  private:
   /// data register
diff --git a/src/driver/pl011/pl011.cpp b/src/driver/pl011/pl011.cpp
index be4fa149..a1c5bb78 100644
--- a/src/driver/pl011/pl011.cpp
+++ b/src/driver/pl011/pl011.cpp
@@ -50,3 +50,12 @@ void Pl011::PutChar(uint8_t c) {
 
   io::Out<uint32_t>(base_addr_ + kRegDR, c);
 }
+
+auto Pl011::GetChar() -> uint8_t {
+  // Wait until there is data in the FIFO or device is disabled
+  while (io::In<uint32_t>(base_addr_ + kRegFR) & kFRRXFE) {
+    ;
+  }
+
+  return io::In<uint32_t>(base_addr_ + kRegDR);
+}
diff --git a/src/driver/plic/CMakeLists.txt b/src/driver/plic/CMakeLists.txt
new file mode 100644
index 00000000..eb2ec181
--- /dev/null
+++ b/src/driver/plic/CMakeLists.txt
@@ -0,0 +1,10 @@
+# This file is a part of Simple-XX/SimpleKernel
+# (https://github.com/Simple-XX/SimpleKernel).
+#
+# CMakeLists.txt for Simple-XX/SimpleKernel.
+
+ADD_LIBRARY (plic INTERFACE)
+
+TARGET_INCLUDE_DIRECTORIES (plic INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
+
+TARGET_SOURCES (plic INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/plic.cpp)
diff --git a/src/driver/plic/README.md b/src/driver/plic/README.md
new file mode 100644
index 00000000..96d950ec
--- /dev/null
+++ b/src/driver/plic/README.md
@@ -0,0 +1,18 @@
+# Platform-Level Interrupt Controller (plic)
+
+riscv64 外部中断控制器
+
+https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic-1.0.0.pdf
+
+```
+plic@c000000 {
+	phandle = <0x05>;
+	riscv,ndev = <0x5f>;
+	reg = <0x00 0xc000000 0x00 0x600000>;
+	interrupts-extended = <0x04 0x0b 0x04 0x09 0x02 0x0b 0x02 0x09>;
+	interrupt-controller;
+	compatible = "sifive,plic-1.0.0\0riscv,plic0";
+	#address-cells = <0x00>;
+	#interrupt-cells = <0x01>;
+};
+```
diff --git a/src/driver/plic/include/plic.h b/src/driver/plic/include/plic.h
new file mode 100644
index 00000000..381ac776
--- /dev/null
+++ b/src/driver/plic/include/plic.h
@@ -0,0 +1,195 @@
+/**
+ * @file plic.h
+ * @brief plic 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_DRIVER_PLIC_INCLUDE_PLIC_H_
+#define SIMPLEKERNEL_SRC_DRIVER_PLIC_INCLUDE_PLIC_H_
+
+#include <array>
+#include <cstddef>
+#include <cstdint>
+#include <tuple>
+
+/**
+ * @brief Plic 驱动
+ * @see https://github.com/riscv/riscv-plic
+ */
+class Plic {
+ public:
+  /**
+   * 构造函数
+   * @param dev_addr 设备地址
+   * @param ndev 支持的中断源数量 (riscv,ndev)
+   * @param context_count 上下文数量 (通常为 2 * core_count)
+   */
+  explicit Plic(uint64_t dev_addr, size_t ndev, size_t context_count);
+
+  /// @name 默认构造/析构函数
+  /// @{
+  Plic() = default;
+  Plic(const Plic& plic) = default;
+  Plic(Plic&& plic) = default;
+  auto operator=(const Plic& plic) -> Plic& = default;
+  auto operator=(Plic&& plic) -> Plic& = default;
+  ~Plic() = default;
+  /// @}
+
+  /**
+   * @brief 执行中断处理
+   * @param  cause 中断或异常号
+   * @param  context 中断上下文
+   */
+  void Do(uint64_t cause, uint8_t* context) const;
+
+  /**
+   * @brief 向 Plic 询问中断
+   * @return uint32_t 中断源 ID (1-1023)
+   */
+  auto Which() const -> uint32_t;
+
+  /**
+   * @brief 告知 Plic 已经处理了当前 IRQ
+   * @param  source_id 中断源 ID (1-1023)
+   */
+  void Done(uint32_t source_id) const;
+
+  /**
+   * @brief 设置指定中断源的使能状态
+   * @param hart_id hart ID
+   * @param source_id 中断源 ID (1-1023)
+   * @param priority 中断优先级 (0-7, 0 表示禁用)
+   * @param enable 是否使能该中断
+   */
+  void Set(uint32_t hart_id, uint32_t source_id, uint32_t priority,
+           bool enable) const;
+
+  /**
+   * @brief 获取指定中断源的状态信息
+   * @param hart_id hart ID
+   * @param source_id 中断源 ID (1-1023)
+   * @return <优先级, 使能状态, 挂起状态>
+   */
+  auto Get(uint32_t hart_id, uint32_t source_id) const
+      -> std::tuple<uint32_t, bool, bool>;
+
+  // /**
+  //  * @brief 注册外部中断处理函数
+  //  * @param  cause             外部中断号
+  //  * @param  _interrupt_handler 外部中断处理函数
+  //  */
+  // void register_externel_handler(
+  //     uint8_t cause, InterruptFunc _interrupt_handler);
+
+  // /**
+  //  * @brief 执行外部中断处理
+  //  * @param  cause              外部中断号
+  //  */
+  // void do_externel_interrupt(uint8_t cause);
+
+ private:
+  static constexpr const uint64_t kSourcePriorityOffset = 0x000000;
+  static constexpr const uint64_t kPendingBitsOffset = 0x001000;
+  static constexpr const uint64_t kEnableBitsOffset = 0x002000;
+  static constexpr const uint64_t kContextOffset = 0x200000;
+
+  // 每个 context 的大小和偏移
+  static constexpr const uint64_t kContextSize = 0x1000;
+  static constexpr const uint64_t kPriorityThresholdOffset = 0x0;
+  static constexpr const uint64_t kClaimCompleteOffset = 0x4;
+
+  // Enable bits 每个 context 的大小 (最多支持 1024 个中断源)
+  static constexpr const uint64_t kEnableSize = 0x80;
+
+  /**
+   * @brief 外部中断处理函数指针
+   * @param cause 中断号
+   */
+  typedef void (*InterruptFunc)(uint8_t cause);
+
+  /// 最大外部中断数量
+  static constexpr const size_t kInterruptMaxCount = 16;
+
+  /// 外部中断处理函数数组
+  static std::array<InterruptFunc, kInterruptMaxCount>
+      external_interrupt_handlers_;
+
+  uint64_t base_addr_ = 0;
+  size_t ndev_ = 0;
+  size_t context_count_ = 0;
+
+  /**
+   * @brief 计算 context ID
+   * @param hart_id hart ID
+   * @param mode 模式 (0=M-mode, 1=S-mode)
+   * @return uint32_t context ID
+   * @note 2 个模式的 context ID 计算方式为: hart_id * 2 + mode
+   */
+  __always_inline auto GetContextId(uint32_t hart_id, uint32_t mode = 1) const
+      -> uint32_t {
+    return hart_id * 2 + mode;
+  }
+
+  /**
+   * @brief 获取使能位寄存器中指定中断源的状态
+   * @param context_id context ID
+   * @param source_id 中断源 ID (1-1023，0 保留)
+   * @return bool 对应位的状态
+   */
+  auto GetEnableBit(uint32_t context_id, uint32_t source_id) const -> bool;
+
+  /**
+   * @brief 设置使能位寄存器中指定中断源的状态
+   * @param context_id context ID
+   * @param source_id 中断源 ID (1-1023，0 保留)
+   * @param value 要设置的值
+   */
+  auto SetEnableBit(uint32_t context_id, uint32_t source_id, bool value) const
+      -> void;
+
+  /**
+   * @brief 获取中断源优先级寄存器
+   * @param source_id 中断源 ID (1-1023，0 保留)
+   * @return uint32_t& 寄存器引用
+   */
+  auto SourcePriority(uint32_t source_id) const -> uint32_t&;
+
+  /**
+   * @brief 获取挂起位寄存器中指定中断源的状态
+   * @param source_id 中断源 ID (1-1023，0 保留)
+   * @return bool 对应位的状态
+   */
+  auto GetPendingBit(uint32_t source_id) const -> bool;
+
+  /**
+   * @brief 设置挂起位寄存器中指定中断源的状态
+   * @param source_id 中断源 ID (1-1023，0 保留)
+   * @param value 要设置的值
+   */
+  auto SetPendingBit(uint32_t source_id, bool value) const -> void;
+
+  /**
+   * @brief 获取优先级阈值寄存器
+   * @param context_id context ID
+   * @return uint32_t& 寄存器引用
+   */
+  auto PriorityThreshold(uint32_t context_id) const -> uint32_t&;
+
+  /**
+   * @brief 获取声明/完成寄存器
+   * @param context_id context ID
+   * @return uint32_t& 寄存器引用
+   */
+  auto ClaimComplete(uint32_t context_id) const -> uint32_t&;
+};
+#endif /* SIMPLEKERNEL_SRC_DRIVER_PLIC_INCLUDE_PLIC_H_ */
diff --git a/src/driver/plic/plic.cpp b/src/driver/plic/plic.cpp
new file mode 100644
index 00000000..4ba9d9c6
--- /dev/null
+++ b/src/driver/plic/plic.cpp
@@ -0,0 +1,153 @@
+/**
+ * @file plic.h
+ * @brief plic 头文件
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2024-05-24
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2024-05-24<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#include "plic.h"
+
+#include <cpu_io.h>
+
+#include "basic_info.hpp"
+#include "kernel_log.hpp"
+#include "sk_string.h"
+
+alignas(
+    4) std::array<Plic::InterruptFunc,
+                  Plic::kInterruptMaxCount> Plic::external_interrupt_handlers_;
+
+Plic::Plic(uint64_t dev_addr, size_t ndev, size_t context_count)
+    : base_addr_(dev_addr), ndev_(ndev), context_count_(context_count) {
+  // 设置所有中断源的优先级为 0 (禁用)
+  klog::Info("Setting all interrupt priorities to 0\n");
+  for (size_t source_id = 0; source_id <= ndev_; source_id++) {
+    SourcePriority(source_id) = 0;
+  }
+
+  klog::Info("Disabling all interrupts for all contexts\n");
+
+  for (size_t context_id = 0; context_id < context_count_; context_id++) {
+    // 设置优先级阈值为 0 (允许所有优先级的中断)
+    PriorityThreshold(context_id) = 0;
+    // 禁用所有中断
+    for (size_t source_id = 0; source_id <= ndev_; source_id++) {
+      SetEnableBit(context_id, source_id, false);
+    }
+  }
+
+  klog::Info(
+      "PLIC initialization: all interrupts disabled, priorities set to 0\n");
+}
+
+auto Plic::Which() const -> uint32_t {
+  auto context_id = GetContextId(cpu_io::GetCurrentCoreId());
+  return ClaimComplete(context_id);
+}
+
+void Plic::Done(uint32_t source_id) const {
+  auto context_id = GetContextId(cpu_io::GetCurrentCoreId());
+  ClaimComplete(context_id) = source_id;
+}
+
+// void Plic::register_externel_handler(
+//     uint8_t cause, InterruptFunc _interrupt_handler) {
+//   externel_interrupt_handlers[cause] = _interrupt_handler;
+//   return;
+// }
+
+// void Plic::do_externel_interrupt(uint8_t cause) {
+//   externel_interrupt_handlers[cause](cause);
+//   return;
+// }
+
+void Plic::Set(uint32_t hart_id, uint32_t source_id, uint32_t priority,
+               bool enable) const {
+  // 设置中断优先级
+  SourcePriority(source_id) = priority;
+
+  // 设置中断使能状态
+  uint32_t context_id = GetContextId(hart_id);
+  SetEnableBit(context_id, source_id, enable);
+}
+
+auto Plic::Get(uint32_t hart_id, uint32_t source_id) const
+    -> std::tuple<uint32_t, bool, bool> {
+  // 获取中断优先级
+  auto priority = SourcePriority(source_id);
+
+  // 获取中断使能状态
+  uint32_t context_id = GetContextId(hart_id);
+  auto enabled = GetEnableBit(context_id, source_id);
+
+  // 获取中断挂起状态
+  auto pending = GetPendingBit(source_id);
+
+  return {priority, enabled, pending};
+}
+
+auto Plic::GetEnableBit(uint32_t context_id, uint32_t source_id) const -> bool {
+  uint32_t word_index = source_id / 32;
+  uint32_t bit_index = source_id % 32;
+  uint32_t* word_addr =
+      (uint32_t*)(base_addr_ + kEnableBitsOffset + (context_id * kEnableSize) +
+                  (word_index * 4));
+  return (*word_addr >> bit_index) & 1;
+}
+
+auto Plic::SetEnableBit(uint32_t context_id, uint32_t source_id,
+                        bool value) const -> void {
+  uint32_t word_index = source_id / 32;
+  uint32_t bit_index = source_id % 32;
+  uint32_t* word_addr =
+      (uint32_t*)(base_addr_ + kEnableBitsOffset + (context_id * kEnableSize) +
+                  (word_index * 4));
+  if (value) {
+    *word_addr |= (1U << bit_index);
+  } else {
+    *word_addr &= ~(1U << bit_index);
+  }
+}
+
+auto Plic::SourcePriority(uint32_t source_id) const -> uint32_t& {
+  return *(uint32_t*)(base_addr_ + kSourcePriorityOffset +
+                      (source_id * sizeof(uint32_t)));
+}
+
+auto Plic::GetPendingBit(uint32_t source_id) const -> bool {
+  uint32_t word_index = source_id / 32;
+  uint32_t bit_index = source_id % 32;
+  uint32_t* word_addr =
+      (uint32_t*)(base_addr_ + kPendingBitsOffset + (word_index * 4));
+  return (*word_addr >> bit_index) & 1;
+}
+
+auto Plic::SetPendingBit(uint32_t source_id, bool value) const -> void {
+  uint32_t word_index = source_id / 32;
+  uint32_t bit_index = source_id % 32;
+  uint32_t* word_addr =
+      (uint32_t*)(base_addr_ + kPendingBitsOffset + (word_index * 4));
+  if (value) {
+    *word_addr |= (1U << bit_index);
+  } else {
+    *word_addr &= ~(1U << bit_index);
+  }
+}
+
+auto Plic::PriorityThreshold(uint32_t context_id) const -> uint32_t& {
+  return *(uint32_t*)(base_addr_ + kContextOffset +
+                      (context_id * kContextSize) + kPriorityThresholdOffset);
+}
+
+auto Plic::ClaimComplete(uint32_t context_id) const -> uint32_t& {
+  return *(uint32_t*)(base_addr_ + kContextOffset +
+                      (context_id * kContextSize) + kClaimCompleteOffset);
+}
diff --git a/src/include/interrupt_base.h b/src/include/interrupt_base.h
new file mode 100644
index 00000000..8afdcb0b
--- /dev/null
+++ b/src/include/interrupt_base.h
@@ -0,0 +1,60 @@
+
+/**
+ * @file interrupt_base.h
+ * @brief 中断处理接口
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-07-15
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-07-15<td>Zone.N (Zone.Niuzh@hotmail.com)<td>创建文件
+ * </table>
+ */
+
+#ifndef SIMPLEKERNEL_SRC_KERNEL_INCLUDE_INTERRUPT_BASE_H_
+#define SIMPLEKERNEL_SRC_KERNEL_INCLUDE_INTERRUPT_BASE_H_
+
+#include <atomic>
+#include <cstdint>
+#include <functional>
+
+class InterruptBase {
+ public:
+  /// @todo functional 报错
+  // typedef std::function<uint64_t(uint64_t, uint8_t *)> InterruptFunc;
+  /**
+   * @brief 中断/异常处理函数指针
+   * @param  cause 中断或异常号
+   * @param  context 中断上下文
+   * @return uint64_t 返回值，0 成功
+   */
+  typedef uint64_t (*InterruptFunc)(uint64_t cause, uint8_t *context);
+
+  /// @name 构造/析构函数
+  /// @{
+  InterruptBase() = default;
+  InterruptBase(const InterruptBase &) = delete;
+  InterruptBase(InterruptBase &&) = delete;
+  auto operator=(const InterruptBase &) -> InterruptBase & = delete;
+  auto operator=(InterruptBase &&) -> InterruptBase & = delete;
+  virtual ~InterruptBase() = default;
+  /// @}
+
+  /**
+   * @brief 执行中断处理
+   * @param 不同平台有不同含义
+   */
+  virtual void Do(uint64_t, uint8_t *) = 0;
+
+  /**
+   * @brief 注册中断处理函数
+   * @param cause 中断号，不同平台有不同含义
+   * @param func 处理函数
+   */
+  virtual void RegisterInterruptFunc(uint64_t cause, InterruptFunc func) = 0;
+};
+
+#endif /* SIMPLEKERNEL_SRC_KERNEL_INCLUDE_INTERRUPT_BASE_H_ */
diff --git a/src/include/kernel.h b/src/include/kernel.h
index cbe5bc10..82586dc2 100644
--- a/src/include/kernel.h
+++ b/src/include/kernel.h
@@ -40,4 +40,7 @@ extern "C" [[maybe_unused]] [[noreturn]] void _start(int argc,
  */
 auto main(int argc, const char** argv) -> int;
 
+auto InterruptInit(int argc, const char** argv) -> int;
+auto InterruptInitSMP(int argc, const char** argv) -> int;
+
 #endif /* SIMPLEKERNEL_SRC_INCLUDE_KERNEL_H_ */
diff --git a/src/include/kernel_fdt.hpp b/src/include/kernel_fdt.hpp
index 7e936048..55046420 100644
--- a/src/include/kernel_fdt.hpp
+++ b/src/include/kernel_fdt.hpp
@@ -1,4 +1,3 @@
-
 /**
  * @file kernel_fdt.hpp
  * @brief 用于解析内核自身的 fdt 解析
@@ -30,8 +29,10 @@
 #pragma GCC diagnostic pop
 #endif
 
+#include <array>
 #include <cstddef>
 #include <cstdint>
+#include <tuple>
 #include <utility>
 
 #include "kernel_log.hpp"
@@ -296,7 +297,7 @@ class KernelFdt {
    * @note 仅支持单个 dist+redist
    * @see https://github.com/qemu/qemu/blob/master/hw/arm/virt.c
    */
-  [[nodiscard]] auto GetGIC() const -> std::pair<uint64_t, uint64_t> {
+  [[nodiscard]] auto GetGic() const -> std::pair<uint64_t, uint64_t> {
     uint64_t dist_base = 0;
     uint64_t redist_base = 0;
 
@@ -390,6 +391,70 @@ class KernelFdt {
 
     return intid;
   }
+
+  /**
+   * 获取 plic 信息
+   * @return 内存信息<地址，长度，中断源数量，上下文数量>
+   * @see https://github.com/qemu/qemu/blob/master/hw/arm/virt.c
+   */
+
+  [[nodiscard]] auto GetPlic() const
+      -> std::tuple<uint64_t, uint64_t, uint32_t, uint32_t> {
+    uint64_t base_addr = 0;
+    uint64_t size = 0;
+    uint32_t ndev = 0;
+    uint32_t context_count = 0;
+
+    int len = 0;
+    int offset = 0;
+
+    std::array<const char *, 2> compatible_str = {"sifive,plic-1.0.0",
+                                                  "riscv,plic0"};
+
+    for (const auto &compatible : compatible_str) {
+      offset = fdt_node_offset_by_compatible(fdt_header_, -1, compatible);
+      if (offset != -FDT_ERR_NOTFOUND) {
+        break;
+      }
+    }
+    if (offset < 0) {
+      ERR("Error finding interrupt controller node: %s\n",
+          fdt_strerror(offset));
+      throw;
+    }
+
+    // 通过 interrupts-extended 字段计算上下文数量
+    auto prop =
+        fdt_get_property(fdt_header_, offset, "interrupts-extended", &len);
+    if (prop == nullptr) {
+      throw;
+    }
+
+    // interrupts-extended 格式: <cpu_phandle interrupt_id> 成对出现
+    // 每两个 uint32_t 值表示一个上下文 (CPU + 模式)
+    uint32_t num_entries = len / sizeof(uint32_t);
+    // 每两个条目表示一个上下文
+    context_count = num_entries / 2;
+
+    // 获取 ndev 属性
+    prop = fdt_get_property(fdt_header_, offset, "riscv,ndev", &len);
+    if (prop == nullptr) {
+      throw;
+    }
+    ndev = fdt32_to_cpu(*reinterpret_cast<const uint32_t *>(prop->data));
+
+    // 获取 reg 属性
+    prop = fdt_get_property(fdt_header_, offset, "reg", &len);
+    if (prop == nullptr) {
+      throw;
+    }
+
+    const auto *reg = reinterpret_cast<const uint64_t *>(prop->data);
+    base_addr = fdt64_to_cpu(reg[0]);
+    size = fdt64_to_cpu(reg[1]);
+
+    return {base_addr, size, ndev, context_count};
+  }
 };
 
 #endif /* SIMPLEKERNEL_SRC_INCLUDE_KERNEL_FDT_HPP_ */
diff --git a/src/include/kernel_log.hpp b/src/include/kernel_log.hpp
index d6ef724a..515388a0 100644
--- a/src/include/kernel_log.hpp
+++ b/src/include/kernel_log.hpp
@@ -1,3 +1,4 @@
+
 /**
  * @file kernel_log.hpp
  * @brief 内核日志相关函数
@@ -30,28 +31,6 @@
 namespace klog {
 namespace detail {
 
-// 日志专用的自旋锁实例
-inline SpinLock& GetLogLock() {
-  static SpinLock log_lock("kernel_log");
-  return log_lock;
-}
-
-/**
- * @brief RAII 风格的锁守护类，确保异常安全
- */
-class LogLockGuard {
- public:
-  explicit LogLockGuard() { GetLogLock().lock(); }
-
-  ~LogLockGuard() { GetLogLock().unlock(); }
-
-  // 禁止拷贝和移动
-  LogLockGuard(const LogLockGuard&) = delete;
-  LogLockGuard(LogLockGuard&&) = delete;
-  LogLockGuard& operator=(const LogLockGuard&) = delete;
-  LogLockGuard& operator=(LogLockGuard&&) = delete;
-};
-
 /// ANSI 转义码，在支持 ANSI 转义码的终端中可以显示颜色
 static constexpr const auto kReset = "\033[0m";
 static constexpr const auto kRed = "\033[31m";
@@ -136,7 +115,7 @@ struct LogBase {
                    [[maybe_unused]] const std::source_location& location =
                        std::source_location::current()) {
     constexpr auto* color = kLogColors[Level];
-    LogLockGuard lock_guard;
+    Singleton<SpinLock>::GetInstance().lock();
     sk_printf("%s[%ld]", color, cpu_io::GetCurrentCoreId());
     if constexpr (Level == kDebug && kSimpleKernelDebugLog) {
       sk_printf("[%s] ", location.function_name());
@@ -147,6 +126,7 @@ struct LogBase {
     sk_printf(args...);
 #pragma GCC diagnostic pop
     sk_printf("%s", detail::kReset);
+    Singleton<SpinLock>::GetInstance().unlock();
   }
 };
 
@@ -164,12 +144,13 @@ Debug(Args&&...) -> Debug<Args...>;
 
 __always_inline void DebugBlob(const void* data, size_t size) {
   if constexpr (kSimpleKernelDebugLog) {
-    detail::LogLockGuard lock_guard;
+    Singleton<SpinLock>::GetInstance().lock();
     sk_printf("%s[%ld] ", detail::kMagenta, cpu_io::GetCurrentCoreId());
     for (size_t i = 0; i < size; i++) {
       sk_printf("0x%02X ", reinterpret_cast<const uint8_t*>(data)[i]);
     }
     sk_printf("%s\n", detail::kReset);
+    Singleton<SpinLock>::GetInstance().unlock();
   }
 }
 
diff --git a/src/include/per_cpu.hpp b/src/include/per_cpu.hpp
index 2eafcdb0..51851db2 100644
--- a/src/include/per_cpu.hpp
+++ b/src/include/per_cpu.hpp
@@ -32,7 +32,7 @@ namespace per_cpu {
 class PerCpu {
  public:
   /// 最大 CPU 数
-  static constexpr size_t kMaxCoreCount = 4;
+  static constexpr const size_t kMaxCoreCount = 4;
 
   /// 核心 ID
   const size_t core_id_;
diff --git a/src/main.cpp b/src/main.cpp
index 7ebe240e..5bd38aa8 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -28,6 +28,7 @@ namespace {
 /// 非启动核入口
 auto main_smp(int argc, const char **argv) -> int {
   ArchInitSMP(argc, argv);
+  InterruptInitSMP(argc, argv);
   klog::Info("Hello SimpleKernel SMP\n");
   return 0;
 }
@@ -50,13 +51,8 @@ void _start(int argc, const char **argv) {
 }
 
 auto main(int argc, const char **argv) -> int {
-  // 架构相关初始化
   ArchInit(argc, argv);
-
-  // klog::Debug("Hello SimpleKernel\n");
-  // klog::Info("Hello SimpleKernel\n");
-  // klog::Warn("Hello SimpleKernel\n");
-  // klog::Err("Hello SimpleKernel\n");
+  InterruptInit(argc, argv);
 
   DumpStack();
 
diff --git a/test/unit_test/riscv64_cpu_test.cpp b/test/unit_test/riscv64_cpu_test.cpp
new file mode 100644
index 00000000..430e2dd7
--- /dev/null
+++ b/test/unit_test/riscv64_cpu_test.cpp
@@ -0,0 +1,143 @@
+
+/**
+ * @file riscv64_cpu_test.cpp
+ * @brief riscv64 cpu 相关测试
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-09-02
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-09-02<td>Zone.N<td>创建文件
+ * </table>
+ */
+
+#include <gtest/gtest.h>
+
+#include "riscv64/include/cpu/cpu.hpp"
+
+TEST(Riscv64RegInfoBaseTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kBitWidth, 64);
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kBitMask, 0xFFFFFFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kAllSetMask, 0xFFFFFFFFFFFFFFFF);
+}
+
+TEST(Riscv64FpInfoTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::FpInfo::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::FpInfo::kBitWidth, 64);
+  EXPECT_EQ(cpu::register_info::FpInfo::kBitMask, 0xFFFFFFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::FpInfo::kAllSetMask, 0xFFFFFFFFFFFFFFFF);
+}
+
+TEST(Riscv64SstatusInfoSieTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Sie::kBitOffset, 1);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Sie::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Sie::kBitMask, 2);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Sie::kAllSetMask, 1);
+}
+
+TEST(Riscv64SstatusInfoSpieTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spie::kBitOffset, 5);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spie::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spie::kBitMask, 0x20);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spie::kAllSetMask, 1);
+}
+
+TEST(Riscv64SstatusInfoSppTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spp::kBitOffset, 8);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spp::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spp::kBitMask, 0x100);
+  EXPECT_EQ(cpu::register_info::csr::SstatusInfo::Spp::kAllSetMask, 1);
+}
+
+TEST(Riscv64StvecInfoModeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::StvecInfo::Mode::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::csr::StvecInfo::Mode::kBitWidth, 2);
+  EXPECT_EQ(cpu::register_info::csr::StvecInfo::Mode::kBitMask, 0x3);
+  EXPECT_EQ(cpu::register_info::csr::StvecInfo::Mode::kAllSetMask, 0x3);
+}
+
+TEST(Riscv64SipInfoSsipTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Ssip::kBitOffset, 1);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Ssip::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Ssip::kBitMask, 0x2);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Ssip::kAllSetMask, 1);
+}
+
+TEST(Riscv64SipInfoStipTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Stip::kBitOffset, 05);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Stip::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Stip::kBitMask, 0x20);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Stip::kAllSetMask, 1);
+}
+
+TEST(Riscv64SipInfoSeipTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Seip::kBitOffset, 9);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Seip::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Seip::kBitMask, 0x200);
+  EXPECT_EQ(cpu::register_info::csr::SipInfo::Seip::kAllSetMask, 1);
+}
+
+TEST(Riscv64SieInfoSsiepTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Ssie::kBitOffset, 1);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Ssie::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Ssie::kBitMask, 0x2);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Ssie::kAllSetMask, 1);
+}
+
+TEST(Riscv64SieInfoStieTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Stie::kBitOffset, 5);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Stie::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Stie::kBitMask, 0x20);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Stie::kAllSetMask, 1);
+}
+
+TEST(Riscv64SieInfoSeieTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Seie::kBitOffset, 9);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Seie::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Seie::kBitMask, 0x200);
+  EXPECT_EQ(cpu::register_info::csr::SieInfo::Seie::kAllSetMask, 1);
+}
+
+TEST(Riscv64ScauseInfoExceptionCodeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::ExceptionCode::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::ExceptionCode::kBitWidth, 63);
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::ExceptionCode::kBitMask,
+            0x7FFFFFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::ExceptionCode::kAllSetMask,
+            0x7FFFFFFFFFFFFFFF);
+}
+
+TEST(Riscv64ScauseInfoInterruptTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::Interrupt::kBitOffset, 63);
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::Interrupt::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::Interrupt::kBitMask,
+            0x8000000000000000);
+  EXPECT_EQ(cpu::register_info::csr::ScauseInfo::Interrupt::kAllSetMask, 1);
+}
+
+TEST(Riscv64SatpInfoPpnTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Ppn::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Ppn::kBitWidth, 44);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Ppn::kBitMask, 0xFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Ppn::kAllSetMask, 0xFFFFFFFFFFF);
+}
+
+TEST(Riscv64SatpInfoAsidTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Asid::kBitOffset, 44);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Asid::kBitWidth, 16);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Asid::kBitMask,
+            ~0xF0000FFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Asid::kAllSetMask, 0xFFFF);
+}
+
+TEST(Riscv64SatpInfoModeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Mode::kBitOffset, 60);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Mode::kBitWidth, 4);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Mode::kBitMask,
+            ~0xFFFFFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::csr::SatpInfo::Mode::kAllSetMask, 0xF);
+}
diff --git a/test/unit_test/x86_64_cpu_test.cpp b/test/unit_test/x86_64_cpu_test.cpp
new file mode 100644
index 00000000..19d19a5e
--- /dev/null
+++ b/test/unit_test/x86_64_cpu_test.cpp
@@ -0,0 +1,112 @@
+
+/**
+ * @file x86_64_cpu_test.cpp
+ * @brief x86_64 cpu 相关测试
+ * @author Zone.N (Zone.Niuzh@hotmail.com)
+ * @version 1.0
+ * @date 2023-09-02
+ * @copyright MIT LICENSE
+ * https://github.com/Simple-XX/SimpleKernel
+ * @par change log:
+ * <table>
+ * <tr><th>Date<th>Author<th>Description
+ * <tr><td>2023-09-02<td>Zone.N<td>创建文件
+ * </table>
+ */
+
+#include <gtest/gtest.h>
+
+#include "x86_64/include/cpu/cpu.hpp"
+#include "x86_64/include/cpu/regs.hpp"
+
+TEST(x8664RegInfoBaseTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kBitWidth, 64);
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kBitMask, 0xFFFFFFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::RegInfoBase::kAllSetMask, 0xFFFFFFFFFFFFFFFF);
+}
+
+TEST(x8664RbpInfoTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::RbpInfo::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::RbpInfo::kBitWidth, 64);
+  EXPECT_EQ(cpu::register_info::RbpInfo::kBitMask, 0xFFFFFFFFFFFFFFFF);
+  EXPECT_EQ(cpu::register_info::RbpInfo::kAllSetMask, 0xFFFFFFFFFFFFFFFF);
+}
+
+TEST(x8664EferInfoSceTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::EferInfo::Sce::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::EferInfo::Sce::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::EferInfo::Sce::kBitMask, 0x1);
+  EXPECT_EQ(cpu::register_info::EferInfo::Sce::kAllSetMask, 1);
+}
+
+TEST(x8664EferInfoLmeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::EferInfo::Lme::kBitOffset, 8);
+  EXPECT_EQ(cpu::register_info::EferInfo::Lme::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::EferInfo::Lme::kBitMask, 0x100);
+  EXPECT_EQ(cpu::register_info::EferInfo::Lme::kAllSetMask, 1);
+}
+
+TEST(x8664EferInfoLmaTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::EferInfo::Lma::kBitOffset, 10);
+  EXPECT_EQ(cpu::register_info::EferInfo::Lma::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::EferInfo::Lma::kBitMask, 0x400);
+  EXPECT_EQ(cpu::register_info::EferInfo::Lma::kAllSetMask, 1);
+}
+
+TEST(x8664EferInfoNxeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::EferInfo::Nxe::kBitOffset, 11);
+  EXPECT_EQ(cpu::register_info::EferInfo::Nxe::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::EferInfo::Nxe::kBitMask, 0x800);
+  EXPECT_EQ(cpu::register_info::EferInfo::Nxe::kAllSetMask, 1);
+}
+
+TEST(x8664RflagsInfoNxeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::RflagsInfo::If::kBitOffset, 9);
+  EXPECT_EQ(cpu::register_info::RflagsInfo::If::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::RflagsInfo::If::kBitMask, 0x200);
+  EXPECT_EQ(cpu::register_info::RflagsInfo::If::kAllSetMask, 1);
+}
+
+TEST(x8664Cr0InfoPeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pe::kBitOffset, 0);
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pe::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pe::kBitMask, 0x1);
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pe::kAllSetMask, 1);
+}
+
+TEST(x8664Cr0InfoPgTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pg::kBitOffset, 31);
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pg::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pg::kBitMask, 0x80000000);
+  EXPECT_EQ(cpu::register_info::cr::Cr0Info::Pg::kAllSetMask, 1);
+}
+
+TEST(x8664Cr3InfoPwtTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pwt::kBitOffset, 3);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pwt::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pwt::kBitMask, 0x8);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pwt::kAllSetMask, 1);
+}
+
+TEST(x8664Cr0InfoPcdTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pcd::kBitOffset, 4);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pcd::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pcd::kBitMask, 0x10);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::Pcd::kAllSetMask, 1);
+}
+TEST(x8664Cr3InfoPageDirectoryBaseTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::PageDirectoryBase::kBitOffset, 12);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::PageDirectoryBase::kBitWidth, 52);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::PageDirectoryBase::kBitMask,
+            ~0xFFF);
+  EXPECT_EQ(cpu::register_info::cr::Cr3Info::PageDirectoryBase::kAllSetMask,
+            0xFFFFFFFFFFFFF);
+}
+
+TEST(x8664Cr4InfoPaeTest, ValueTest) {
+  EXPECT_EQ(cpu::register_info::cr::Cr4Info::Pae::kBitOffset, 5);
+  EXPECT_EQ(cpu::register_info::cr::Cr4Info::Pae::kBitWidth, 1);
+  EXPECT_EQ(cpu::register_info::cr::Cr4Info::Pae::kBitMask, 0x20);
+  EXPECT_EQ(cpu::register_info::cr::Cr4Info::Pae::kAllSetMask, 1);
+}
