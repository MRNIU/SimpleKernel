# 多核唤醒

## x86_64

### 概述

x86_64 架构的多核唤醒机制基于 APIC (Advanced Programmable Interrupt Controller) 系统，通过 INIT-SIPI-SIPI 序列来唤醒应用处理器 (Application Processors, APs)。

### 关键组件

#### 1. APIC 系统
- **Local APIC**: 每个 CPU 核心都有一个 Local APIC，负责处理核心间通信
- **IO APIC**: 系统级别的中断控制器，处理外部中断
- **支持两种模式**:
  - xAPIC: 传统模式，通过内存映射访问
  - x2APIC: 扩展模式，通过 MSR 访问，性能更好

#### 2. 核心数据结构

**SIPI 参数结构** (`src/arch/x86_64/sipi.h`):
```cpp
struct sipi_params_t {
  uint32_t cr3;  // 页表基地址
} __attribute__((packed));
```

**Per-CPU 数据** (`src/include/per_cpu.hpp`):
```cpp
class PerCpu {
  static constexpr size_t kMaxCoreCount = 4;
  const size_t core_id_;
  ssize_t noff_{0};          // 中断嵌套深度
  bool intr_enable_{false};  // 中断使能状态
};
```

### 多核启动流程

#### 1. BSP (Bootstrap Processor) 初始化
在 `src/arch/x86_64/arch_main.cpp` 的 `ArchInit()` 函数中：

```cpp
// 1. 初始化 APIC 系统
Singleton<Apic>::GetInstance() = Apic(core_count);
Singleton<Apic>::GetInstance().InitCurrentCpuLocalApic();

// 2. 填充 SIPI 参数
auto target_sipi_params = reinterpret_cast<sipi_params_t *>(sipi_params);
target_sipi_params->cr3 = cpu_io::Cr3::Read();

// 3. 唤醒所有 AP
Singleton<Apic>::GetInstance().StartupAllAps(
    reinterpret_cast<uint64_t>(ap_start16),
    reinterpret_cast<size_t>(ap_start64_end) - reinterpret_cast<size_t>(ap_start16),
    kDefaultAPBase);
```

#### 2. AP 启动代码
位于 `src/arch/x86_64/boot.S`，包含完整的模式切换序列：

**16位实模式启动** (`ap_start16`):
```assembly
// 关中断，清除 TLB
cli
xor %eax, %eax
mov %eax, %cr3

// 加载 GDT 并启用保护模式
mov $gdtdesc, %ebx
sub $ap_start16, %ebx
data32 lgdt (%ebx)

mov %cr0, %eax
or $PROTECTION_MODE_BIT,%eax
mov %eax, %cr0
```

**32位保护模式** (`ap_start32`):
```assembly
// 启用 PAE
mov %cr4, %eax
or $PAE_BIT, %eax
mov %eax, %cr4

// 设置页表（使用 BSP 的 CR3）
mov $cr3, %ebx
sub $ap_start16, %ebx
mov (%ebx), %eax
mov %eax, %cr3

// 启用长模式
mov $IA32_EFER_MSR, %ecx
rdmsr
or $LONG_MODE_BIT, %eax
wrmsr

// 启用分页
mov %cr0, %eax
or $PAGING_BIT, %eax
mov %eax, %cr0
```

**64位长模式** (`_boot`):
```assembly
// 获取 APIC ID 作为 CPU ID
mov $CPUID_LEAF_1, %eax
cpuid
shr $APIC_ID_SHIFT, %ebx
and $APIC_ID_MASK, %ebx

// 根据 CPU ID 设置独立栈
mov %ebx, %eax
mov $STACK_SIZE_PER_CPU, %edx
mul %edx
mov $stack_top, %rsp
add %rax, %rsp
add $STACK_SIZE_PER_CPU, %rsp

// 跳转到内核入口
call _start
```

#### 3. INIT-SIPI-SIPI 序列
在 `src/driver/apic/local_apic.cpp` 的 `WakeupAp()` 函数中实现：

```cpp
void LocalApic::WakeupAp(uint32_t destination_apic_id, uint8_t start_vector) const {
  // 1. 发送 INIT IPI
  SendInitIpi(destination_apic_id);

  // 2. 等待 10ms
  auto delay = 10 * kCalibrationDelayLoop;
  while (delay--) { __asm__ volatile("nop"); }

  // 3. 发送第一个 SIPI
  SendStartupIpi(destination_apic_id, start_vector);

  // 4. 等待 200μs
  delay = 200 * (kCalibrationDelayLoop / 1000);
  while (delay--) { __asm__ volatile("nop"); }

  // 5. 发送第二个 SIPI（提高可靠性）
  SendStartupIpi(destination_apic_id, start_vector);

  // 6. 等待 200μs
  delay = 200 * (kCalibrationDelayLoop / 1000);
  while (delay--) { __asm__ volatile("nop"); }
}
```

#### 4. AP 入口处理
AP 启动后通过 `src/main.cpp` 的 `_start()` 函数进入：

```cpp
void _start(int argc, const char **argv) {
  if (argv != nullptr) {
    // BSP 路径
    CppInit();
    main(argc, argv);
    CppDeInit();
  } else {
    // AP 路径
    main_smp(argc, argv);
  }

  // 进入死循环
  while (true) { ; }
}
```

AP 执行 `main_smp()` -> `ArchInitSMP()` -> `InitCurrentCpuLocalApic()`

### 内存布局

#### 栈分配
每个 CPU 分配 4KB 独立栈空间：
```cpp
#define STACK_SIZE_PER_CPU      0x1000
#define MAX_CPU_COUNT           4
#define TOTAL_STACK_SIZE        (STACK_SIZE_PER_CPU * MAX_CPU_COUNT)

// CPU ID * 4KB + stack_top 作为该 CPU 的栈顶
```

#### AP 启动代码位置
- 默认复制到物理地址 `0x30000` (`kDefaultAPBase`)
- 必须在 1MB 以下（实模式限制）
- 必须 4KB 对齐（SIPI 要求）

### APIC 配置

#### Local APIC 初始化
```cpp
bool LocalApic::Init() {
  // 1. 检查并启用 APIC 模式（优先 x2APIC）
  if (EnableX2Apic()) {
    is_x2apic_mode_ = true;
  } else {
    EnableXApic();
    is_x2apic_mode_ = false;
  }

  // 2. 设置 SIVR 寄存器
  sivr |= kApicSoftwareEnableBit;  // 启用 APIC
  sivr |= kSpuriousVector;         // 设置虚假中断向量

  // 3. 清除任务优先级
  SetTaskPriority(0);

  // 4. 屏蔽所有 LVT 条目
  WriteLvtTimer(kLvtMaskBit);
  WriteLvtLint0(kLvtMaskBit);
  WriteLvtLint1(kLvtMaskBit);
  WriteLvtError(kLvtMaskBit);
}
```

#### IPI 发送机制
支持两种 IPI 类型：
- **点对点 IPI**: `SendIpi(target_apic_id, vector)`
- **广播 IPI**: `BroadcastIpi(vector)`

### 关键常量定义

```cpp
// APIC 基址和向量
static constexpr uint64_t kDefaultAPBase = 0x30000;

// 模式切换位
#define PAE_BIT                 0x20        // CR4.PAE
#define PROTECTION_MODE_BIT     0x1         // CR0.PE
#define LONG_MODE_BIT           0x100       // EFER.LME
#define PAGING_BIT              0x80000000  // CR0.PG

// APIC ID 相关
#define APIC_ID_SHIFT           24
#define APIC_ID_MASK            0xFF
#define CPUID_LEAF_1            1

// IPI 模式
static constexpr uint32_t kInitIpiMode = 0x00004500;  // INIT
static constexpr uint32_t kSipiMode = 0x00004600;     // SIPI
```

### 特性和限制

#### 支持特性
- 支持最多 4 个 CPU 核心
- 支持 x2APIC 和 xAPIC 两种模式
- 完整的 INIT-SIPI-SIPI 启动序列
- 每个 CPU 独立的栈空间
- Per-CPU 数据结构管理

#### 当前限制
- 最大 CPU 数量硬编码为 4
- IO APIC 功能部分待实现
- 缺少 CPU 热插拔支持
- 简化的错误处理机制

### 调试和监控

系统提供 APIC 信息打印功能：
```cpp
void LocalApic::PrintInfo() const {
  klog::Info("=== Local APIC Information ===\n");
  klog::Info("APIC Version: 0x%x\n", GetApicVersion());
  klog::Info("Mode: %s\n", is_x2apic_mode_ ? "x2APIC" : "xAPIC");
  klog::Info("Task Priority: 0x%x\n", GetTaskPriority());
  // ... 更多寄存器状态
}
```

## RISCV64

## AARCH64

## 相关文档
