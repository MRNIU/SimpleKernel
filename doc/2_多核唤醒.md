# 多核唤醒

## x86_64

### 概述

x86_64 架构的多核唤醒机制基于 APIC (Advanced Programmable Interrupt Controller) 系统，通过 INIT-SIPI-SIPI 序列来唤醒应用处理器 (Application Processors, APs)。

### 关键组件

#### 1. APIC 系统
- **Local APIC**: 每个 CPU 核心都有一个 Local APIC，负责处理核心间通信
- **IO APIC**: 系统级别的中断控制器，处理外部中断
- **支持两种模式**:
  - xAPIC: 传统模式，通过内存映射访问
  - x2APIC: 扩展模式，通过 MSR 访问，性能更好

#### 2. 核心数据结构

**SIPI 参数结构** (`src/arch/x86_64/sipi.h`):
```cpp
struct sipi_params_t {
  uint32_t cr3;  // 页表基地址
} __attribute__((packed));
```

**Per-CPU 数据** (`src/include/per_cpu.hpp`):
```cpp
class PerCpu {
  static constexpr size_t kMaxCoreCount = 4;
  const size_t core_id_;
  ssize_t noff_{0};          // 中断嵌套深度
  bool intr_enable_{false};  // 中断使能状态
};
```

### 多核启动流程

#### 1. BSP (Bootstrap Processor) 初始化
在 `src/arch/x86_64/arch_main.cpp` 的 `ArchInit()` 函数中：

```cpp
// 1. 初始化 APIC 系统
Singleton<Apic>::GetInstance() = Apic(core_count);
Singleton<Apic>::GetInstance().InitCurrentCpuLocalApic();

// 2. 填充 SIPI 参数
auto target_sipi_params = reinterpret_cast<sipi_params_t *>(sipi_params);
target_sipi_params->cr3 = cpu_io::Cr3::Read();

// 3. 唤醒所有 AP
Singleton<Apic>::GetInstance().StartupAllAps(
    reinterpret_cast<uint64_t>(ap_start16),
    reinterpret_cast<size_t>(ap_start64_end) - reinterpret_cast<size_t>(ap_start16),
    kDefaultAPBase);
```

#### 2. AP 启动代码
位于 `src/arch/x86_64/boot.S`，包含完整的模式切换序列：

**16位实模式启动** (`ap_start16`):
```assembly
// 关中断，清除 TLB
cli
xor %eax, %eax
mov %eax, %cr3

// 加载 GDT 并启用保护模式
mov $gdtdesc, %ebx
sub $ap_start16, %ebx
data32 lgdt (%ebx)

mov %cr0, %eax
or $PROTECTION_MODE_BIT,%eax
mov %eax, %cr0
```

**32位保护模式** (`ap_start32`):
```assembly
// 启用 PAE
mov %cr4, %eax
or $PAE_BIT, %eax
mov %eax, %cr4

// 设置页表（使用 BSP 的 CR3）
mov $cr3, %ebx
sub $ap_start16, %ebx
mov (%ebx), %eax
mov %eax, %cr3

// 启用长模式
mov $IA32_EFER_MSR, %ecx
rdmsr
or $LONG_MODE_BIT, %eax
wrmsr

// 启用分页
mov %cr0, %eax
or $PAGING_BIT, %eax
mov %eax, %cr0
```

**64位长模式** (`_boot`):
```assembly
// 获取 APIC ID 作为 CPU ID
mov $CPUID_LEAF_1, %eax
cpuid
shr $APIC_ID_SHIFT, %ebx
and $APIC_ID_MASK, %ebx

// 根据 CPU ID 设置独立栈
mov %ebx, %eax
mov $STACK_SIZE_PER_CPU, %edx
mul %edx
mov $stack_top, %rsp
add %rax, %rsp
add $STACK_SIZE_PER_CPU, %rsp

// 跳转到内核入口
call _start
```

#### 3. INIT-SIPI-SIPI 序列
在 `src/driver/apic/local_apic.cpp` 的 `WakeupAp()` 函数中实现：

```cpp
void LocalApic::WakeupAp(uint32_t destination_apic_id, uint8_t start_vector) const {
  // 1. 发送 INIT IPI
  SendInitIpi(destination_apic_id);

  // 2. 等待 10ms
  auto delay = 10 * kCalibrationDelayLoop;
  while (delay--) { __asm__ volatile("nop"); }

  // 3. 发送第一个 SIPI
  SendStartupIpi(destination_apic_id, start_vector);

  // 4. 等待 200μs
  delay = 200 * (kCalibrationDelayLoop / 1000);
  while (delay--) { __asm__ volatile("nop"); }

  // 5. 发送第二个 SIPI（提高可靠性）
  SendStartupIpi(destination_apic_id, start_vector);

  // 6. 等待 200μs
  delay = 200 * (kCalibrationDelayLoop / 1000);
  while (delay--) { __asm__ volatile("nop"); }
}
```

#### 4. AP 入口处理
AP 启动后通过 `src/main.cpp` 的 `_start()` 函数进入：

```cpp
void _start(int argc, const char **argv) {
  if (argv != nullptr) {
    // BSP 路径
    CppInit();
    main(argc, argv);
    CppDeInit();
  } else {
    // AP 路径
    main_smp(argc, argv);
  }

  // 进入死循环
  while (true) { ; }
}
```

AP 执行 `main_smp()` -> `ArchInitSMP()` -> `InitCurrentCpuLocalApic()`

### 内存布局

#### 栈分配
每个 CPU 分配 4KB 独立栈空间：
```cpp
#define STACK_SIZE_PER_CPU      0x1000
#define MAX_CPU_COUNT           4
#define TOTAL_STACK_SIZE        (STACK_SIZE_PER_CPU * MAX_CPU_COUNT)

// CPU ID * 4KB + stack_top 作为该 CPU 的栈顶
```

#### AP 启动代码位置
- 默认复制到物理地址 `0x30000` (`kDefaultAPBase`)
- 必须在 1MB 以下（实模式限制）
- 必须 4KB 对齐（SIPI 要求）

### APIC 配置

#### Local APIC 初始化
```cpp
bool LocalApic::Init() {
  // 1. 检查并启用 APIC 模式（优先 x2APIC）
  if (EnableX2Apic()) {
    is_x2apic_mode_ = true;
  } else {
    EnableXApic();
    is_x2apic_mode_ = false;
  }

  // 2. 设置 SIVR 寄存器
  sivr |= kApicSoftwareEnableBit;  // 启用 APIC
  sivr |= kSpuriousVector;         // 设置虚假中断向量

  // 3. 清除任务优先级
  SetTaskPriority(0);

  // 4. 屏蔽所有 LVT 条目
  WriteLvtTimer(kLvtMaskBit);
  WriteLvtLint0(kLvtMaskBit);
  WriteLvtLint1(kLvtMaskBit);
  WriteLvtError(kLvtMaskBit);
}
```

#### IPI 发送机制
支持两种 IPI 类型：
- **点对点 IPI**: `SendIpi(target_apic_id, vector)`
- **广播 IPI**: `BroadcastIpi(vector)`

### 关键常量定义

```cpp
// APIC 基址和向量
static constexpr uint64_t kDefaultAPBase = 0x30000;

// 模式切换位
#define PAE_BIT                 0x20        // CR4.PAE
#define PROTECTION_MODE_BIT     0x1         // CR0.PE
#define LONG_MODE_BIT           0x100       // EFER.LME
#define PAGING_BIT              0x80000000  // CR0.PG

// APIC ID 相关
#define APIC_ID_SHIFT           24
#define APIC_ID_MASK            0xFF
#define CPUID_LEAF_1            1

// IPI 模式
static constexpr uint32_t kInitIpiMode = 0x00004500;  // INIT
static constexpr uint32_t kSipiMode = 0x00004600;     // SIPI
```

### 特性和限制

#### 支持特性
- 支持最多 4 个 CPU 核心
- 支持 x2APIC 和 xAPIC 两种模式
- 完整的 INIT-SIPI-SIPI 启动序列
- 每个 CPU 独立的栈空间
- Per-CPU 数据结构管理

#### 当前限制
- 最大 CPU 数量硬编码为 4
- IO APIC 功能部分待实现
- 缺少 CPU 热插拔支持
- 简化的错误处理机制

### 调试和监控

系统提供 APIC 信息打印功能：
```cpp
void LocalApic::PrintInfo() const {
  klog::Info("=== Local APIC Information ===\n");
  klog::Info("APIC Version: 0x%x\n", GetApicVersion());
  klog::Info("Mode: %s\n", is_x2apic_mode_ ? "x2APIC" : "xAPIC");
  klog::Info("Task Priority: 0x%x\n", GetTaskPriority());
  // ... 更多寄存器状态
}
```

## RISCV64

### 概述

RISC-V64 架构的多核唤醒机制基于 OpenSBI (Supervisor Binary Interface) 标准，通过 HSM (Hart State Management) 扩展来管理硬件线程（Hart）的启动和状态。与x86_64的复杂INIT-SIPI-SIPI序列不同，RISC-V提供了更简单统一的多核启动接口。

### 关键组件

#### 1. OpenSBI HSM 扩展
- **HSM (Hart State Management)**: RISC-V标准的硬件线程管理接口
- **SBI调用**: 通过`ecall`指令与Machine模式的OpenSBI固件通信
- **Hart状态管理**: 包括STARTED、STOPPED、START_PENDING等状态

#### 2. 核心数据结构

**Hart状态枚举** (`3rd/opensbi_interface/src/include/opensbi_interface.h`):
```cpp
enum {
  HSM_HART_STATE_STARTED = 0,
  HSM_HART_STATE_STOPPED = 1,
  HSM_HART_STATE_START_PENDING = 2,
  HSM_HART_STATE_STOP_PENDING = 3,
  HSM_HART_STATE_SUSPENDED = 4,
  HSM_HART_STATE_SUSPEND_PENDING = 5,
  HSM_HART_STATE_RESUME_PENDING = 6,
};
```

**SBI返回值结构**:
```cpp
struct sbiret {
  long error;   // 错误码
  long value;   // 返回值
};
```

### 多核启动流程

#### 1. BSP (Bootstrap Processor) 初始化
在 `src/arch/riscv64/arch_main.cpp` 的 `ArchInit()` 函数中：

```cpp
void ArchInit(int argc, const char **argv) {
  // 1. 解析设备树获取基本信息
  Singleton<KernelFdt>::GetInstance() = KernelFdt(reinterpret_cast<uint64_t>(argv));
  Singleton<BasicInfo>::GetInstance() = BasicInfo(argc, argv);

  // 2. 解析内核ELF信息
  Singleton<KernelElf>::GetInstance() =
      KernelElf(Singleton<BasicInfo>::GetInstance().elf_addr);

  // 3. 通过SBI唤醒所有Hart
  for (size_t i = 0; i < Singleton<BasicInfo>::GetInstance().core_count; i++) {
    auto ret = sbi_hart_start(i, reinterpret_cast<uint64_t>(_boot), 0);
    if ((ret.error != SBI_SUCCESS) && (ret.error != SBI_ERR_ALREADY_AVAILABLE)) {
      klog::Warn("hart %d start failed: %d\n", i, ret.error);
    }
  }
}
```

#### 2. Hart 启动代码
位于 `src/arch/riscv64/boot.S`，实现简洁的64位启动序列：

```assembly
.section .text.boot
.global _boot
_boot:
    // 检查设备树地址是否有效
    beqz a1, 2f

    // 初始化全局指针寄存器 (可选)
    #if USE_NO_RELAX == 0
.option push
.option norelax
1:  auipc gp, %pcrel_hi(__global_pointer$)
    addi  gp, gp, %pcrel_lo(1b)
.option pop
    #endif

2:  // 根据Hart ID设置独立栈
    add t0, a0, 1        // t0 = hart_id + 1
    slli t0, t0, 12      // t0 *= 4096 (4KB per hart)
    la sp, stack_top     // 加载栈顶基址
    add sp, sp, t0       // sp = stack_top + hart_id * 4KB

    // 保存Hart ID到tp寄存器 (用于获取当前核心ID)
    mv tp, a0

    // 保存SBI传递的参数到栈
    addi sp, sp, -16     // 开辟栈空间
    SdBase a0, 0, sp     // 保存Hart ID
    SdBase a1, 1, sp     // 保存设备树地址

    // 跳转到C代码入口
    call _start

    // 如果返回则进入等待状态
    wfi
```

#### 3. SBI Hart启动接口
`sbi_hart_start()` 函数实现 (`3rd/opensbi_interface/src/opensbi_interface.c`):

```cpp
struct sbiret sbi_hart_start(unsigned long hartid, unsigned long start_addr,
                             unsigned long opaque) {
  return ecall(hartid, start_addr, opaque, 0, 0, 0,
               SBI_EXT_HSM_HART_START, SBI_EXT_HSM);
}
```

#### 4. Hart入口处理
Hart启动后通过 `src/main.cpp` 的 `_start()` 函数进入：

```cpp
void _start(int argc, const char **argv) {
  if (argv != nullptr) {
    // BSP路径 (设备树地址有效)
    CppInit();
    main(argc, argv);
    CppDeInit();
  } else {
    // AP路径 (设备树地址为空)
    main_smp(argc, argv);
  }

  // 进入死循环
  while (true) { ; }
}
```

AP执行 `main_smp()` -> `ArchInitSMP()` (当前为空实现)

### 核心ID获取机制

#### Hart ID管理
RISC-V使用 `tp` (Thread Pointer) 寄存器存储当前Hart ID：

```cpp
// 在boot.S中设置
mv tp, a0  // 将Hart ID保存到tp寄存器

// 在C代码中获取
static __always_inline auto GetCurrentCoreId() -> size_t {
  return Tp::Read();
}
```

#### Tp寄存器访问
通过内联汇编实现：
```cpp
// 读取tp寄存器
static __always_inline auto Read() -> typename RegInfo::DataType {
  typename RegInfo::DataType value{};
  __asm__ volatile("mv %0, tp" : "=r"(value) : :);
  return value;
}

// 写入tp寄存器
static __always_inline void Write(typename RegInfo::DataType value) {
  __asm__ volatile("mv tp, %0" : : "r"(value) :);
}
```

### 设备树信息获取

#### CPU核心数量获取
通过解析设备树获取系统CPU核心数：

```cpp
[[nodiscard]] auto GetCoreCount() const -> size_t {
  size_t core_count = 0;
  auto offset = -1;

  while (true) {
    offset = fdt_next_node(fdt_header_, offset, nullptr);
    if (offset < 0) break;

    const auto *prop = fdt_get_property(fdt_header_, offset, "device_type", nullptr);
    if (prop != nullptr) {
      const char *device_type = reinterpret_cast<const char *>(prop->data);
      if (strcmp(device_type, "cpu") == 0) {
        ++core_count;
      }
    }
  }

  return core_count;
}
```

#### 基本信息初始化
```cpp
BasicInfo::BasicInfo(int, const char **argv) {
  // 从设备树获取内存信息
  auto [memory_base, memory_size] =
      Singleton<KernelFdt>::GetInstance().GetMemory();
  physical_memory_addr = memory_base;
  physical_memory_size = memory_size;

  // 内核地址和大小
  kernel_addr = reinterpret_cast<uint64_t>(__executable_start);
  kernel_size = reinterpret_cast<uint64_t>(end) -
                reinterpret_cast<uint64_t>(__executable_start);

  // 设备树地址
  fdt_addr = reinterpret_cast<uint64_t>(argv);

  // CPU核心数
  core_count = Singleton<KernelFdt>::GetInstance().GetCoreCount();
}
```

### 内存布局

#### 栈分配
每个Hart分配4KB独立栈空间：
```assembly
// Hart栈地址计算: stack_top + (hart_id + 1) * 4KB
add t0, a0, 1        // hart_id + 1
slli t0, t0, 12      // * 4096
la sp, stack_top     // 栈基址
add sp, sp, t0       // 最终栈指针

.section .bss.boot
.align 16
.global stack_top
stack_top:
    .space 4096 * 4  // 总共16KB栈空间
```

### SBI接口详解

#### Hart状态管理接口
```cpp
// 启动Hart
struct sbiret sbi_hart_start(unsigned long hartid,
                             unsigned long start_addr,
                             unsigned long opaque);

// 停止Hart
struct sbiret sbi_hart_stop(void);

// 获取Hart状态
struct sbiret sbi_hart_get_status(unsigned long hartid);

// Hart挂起
struct sbiret sbi_hart_suspend(uint32_t suspend_type,
                               unsigned long resume_addr,
                               unsigned long opaque);
```

#### 错误码定义
```cpp
enum {
  SBI_SUCCESS = 0,
  SBI_ERR_FAILED = -1,
  SBI_ERR_NOT_SUPPORTED = -2,
  SBI_ERR_INVALID_PARAM = -3,
  SBI_ERR_DENIED = -4,
  SBI_ERR_INVALID_ADDRESS = -5,
  SBI_ERR_ALREADY_AVAILABLE = -6,  // Hart已经启动
  SBI_ERR_ALREADY_STARTED = -7,
  SBI_ERR_ALREADY_STOPPED = -8,
  SBI_ERR_NO_SHMEM = -9,
};
```

### 特性和限制

#### 支持特性
- 基于标准SBI HSM扩展的多核启动
- 简洁的64位启动序列，无需模式切换
- 通过设备树动态获取CPU核心数
- 基于tp寄存器的高效核心ID管理
- 完整的Hart状态管理支持

#### 当前限制
- ArchInitSMP()函数为空实现，缺少AP特定初始化
- 缺少Hart间通信机制（IPI）
- 固定的栈大小分配（4KB per Hart）
- 简化的错误处理机制

### 调试和监控

系统提供Hart状态查询功能：
```cpp
auto status = sbi_hart_get_status(hart_id);
if (status.error == SBI_SUCCESS) {
  klog::Info("Hart %d status: %s\n", hart_id,
             HSM_HART_STATES_NAME[status.value]);
}
```

支持的状态包括：
- STARTED: Hart正在运行
- STOPPED: Hart已停止
- START_PENDING: Hart启动中
- STOP_PENDING: Hart停止中
- SUSPENDED: Hart已挂起
- SUSPEND_PENDING: Hart挂起中
- RESUME_PENDING: Hart恢复中

## AARCH64

## 相关文档
