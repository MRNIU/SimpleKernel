# å¤šæ¶æ„ä¸­æ–­å¤„ç†ç³»ç»Ÿ

SimpleKernel å®ç°äº†è·¨å¤šä¸ªæ¶æ„çš„å®Œæ•´ä¸­æ–­å¤„ç†ç³»ç»Ÿï¼Œæ¯ä¸ªæ¶æ„éƒ½æœ‰å…¶ç‰¹å®šçš„ä¸­æ–­æ§åˆ¶å™¨å’Œå¤„ç†æœºåˆ¶ã€‚

## ğŸ—ï¸ æ¶æ„å¯¹æ¯”æ€»è§ˆ

| ç‰¹æ€§ | x86_64 | RISC-V 64 | AArch64 |
|------|--------|-----------|---------|
| ä¸­æ–­æ§åˆ¶å™¨ | APIC/IO-APIC | PLIC/CLINT | GIC |
| ä¸­æ–­æè¿°ç¬¦ | IDT (256æ¡ç›®) | CSR + trap handler | å¼‚å¸¸å‘é‡è¡¨ |
| å®šæ—¶å™¨ | APIC Timer | SBI Timer | Generic Timer |
| å¤–éƒ¨ä¸­æ–­ | IRQé‡å®šå‘ | PLICä¸­æ–­è·¯ç”± | GICåˆ†å‘ |
| å¤šæ ¸å¯åŠ¨ | SIPI | SBI Hartç®¡ç† | PSCI |
| ç‰¹æƒçº§åˆ« | Ring 0-3 | M/S/U Mode | EL0-3 |

---

# x86_64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    x86_64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  InterruptBase (æŠ½è±¡åŸºç±»)                                   â”‚
â”‚  â”œâ”€â”€ Do(cause, context)                                    â”‚
â”‚  â””â”€â”€ RegisterInterruptFunc(cause, func)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Interrupt (x86_64å®ç°)                                     â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­æè¿°ç¬¦è¡¨(IDT) åˆå§‹åŒ–                                â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„ç®¡ç†                                    â”‚
â”‚  â”œâ”€â”€ æ¨¡æ¿é€’å½’åˆå§‹åŒ– IDT æ¡ç›®                                 â”‚
â”‚  â””â”€â”€ ä¸­æ–­åˆ†å‘æœºåˆ¶                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  APIC æ§åˆ¶å™¨é›†æˆ                                            â”‚
â”‚  â”œâ”€â”€ Local APIC å®šæ—¶å™¨                                     â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å‘é‡åˆ†é…                                           â”‚
â”‚  â”œâ”€â”€ EOI (End of Interrupt) å¤„ç†                          â”‚
â”‚  â””â”€â”€ IRQ é‡å®šå‘é…ç½®                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å…·ä½“ä¸­æ–­å¤„ç†å™¨                                             â”‚
â”‚  â”œâ”€â”€ APIC å®šæ—¶å™¨ä¸­æ–­ (0xF0)                                â”‚
â”‚  â”œâ”€â”€ é”®ç›˜ä¸­æ–­ (0xF1)                                       â”‚
â”‚  â””â”€â”€ é»˜è®¤å¼‚å¸¸å¤„ç†å™¨                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ ä¸­æ–­æè¿°ç¬¦è¡¨ (IDT) ç®¡ç†

### IDT åˆå§‹åŒ–æµç¨‹

```cpp
class Interrupt {
    // 256ä¸ªä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„
    static std::array<InterruptFunc, 256> interrupt_handlers;

    // 256ä¸ªä¸­æ–­æè¿°ç¬¦æ¡ç›®
    static std::array<cpu_io::IdtrInfo::Idt, 256> idts;

    // æ¨¡æ¿é€’å½’åˆå§‹åŒ–æ‰€æœ‰IDTæ¡ç›®
    template <uint8_t no = 0>
    void SetUpIdtr();
};
```

### æ¨¡æ¿é€’å½’åˆå§‹åŒ–æœºåˆ¶

```cpp
template <uint8_t no>
void Interrupt::SetUpIdtr() {
    if constexpr (no < kInterruptMaxCount - 1) {
        // ä¸ºæ¯ä¸ªä¸­æ–­å·åˆ›å»ºIDTæ¡ç›®
        idts[no] = cpu_io::IdtrInfo::Idt(
            reinterpret_cast<uint64_t>(TarpEntry<no>),  // ä¸­æ–­å…¥å£åœ°å€
            8,                                          // ä»£ç æ®µé€‰æ‹©å­
            0x0,                                        // IST (ä¸­æ–­æ ˆè¡¨)
            Idt::Type::k64BitInterruptGate,            // 64ä½ä¸­æ–­é—¨
            Idt::DPL::kRing0,                          // ç‰¹æƒçº§åˆ«0
            Idt::P::kPresent                           // å­˜åœ¨ä½
        );
        SetUpIdtr<no + 1>();  // é€’å½’åˆå§‹åŒ–ä¸‹ä¸€ä¸ª
    } else {
        // æœ€åä¸€æ­¥ï¼šå†™å…¥IDTRå¯„å­˜å™¨
        static auto idtr = IdtrInfo::Idtr{
            .limit = sizeof(Idt) * kInterruptMaxCount - 1,
            .base = idts.data(),
        };
        cpu_io::Idtr::Write(idtr);
    }
}
```

### ä¸­æ–­å…¥å£æ¨¡æ¿

æ¯ä¸ªä¸­æ–­å·éƒ½æœ‰ç‹¬ç«‹çš„å…¥å£å‡½æ•°ï¼š

```cpp
template <uint8_t no>
__attribute__((target("general-regs-only")))
__attribute__((interrupt))
void TarpEntry(uint8_t *interrupt_context) {
    // è°ƒç”¨ç»Ÿä¸€çš„ä¸­æ–­åˆ†å‘å™¨
    InterruptSingleton::instance().Do(no, interrupt_context);
}
```

## ğŸ¯ ä¸­æ–­å¤„ç†æµç¨‹

### 1. ç¡¬ä»¶ä¸­æ–­è§¦å‘
```
ç¡¬ä»¶äº‹ä»¶ â†’ CPU ä¸­æ–­ â†’ æŸ¥æ‰¾ IDT[vector] â†’ è°ƒç”¨ TarpEntry<vector>
```

### 2. è½¯ä»¶ä¸­æ–­åˆ†å‘
```cpp
void Interrupt::Do(uint64_t cause, uint8_t *context) {
    if (cause < kInterruptMaxCount) {
        // è°ƒç”¨æ³¨å†Œçš„ä¸­æ–­å¤„ç†å‡½æ•°
        interrupt_handlers[cause](cause, context);
    }
}
```

### 3. ä¸­æ–­å¤„ç†å‡½æ•°æ³¨å†Œ
```cpp
void Interrupt::RegisterInterruptFunc(uint64_t cause, InterruptFunc func) {
    if (cause < kInterruptMaxCount) {
        interrupt_handlers[cause] = func;
        klog::Debug("RegisterInterruptFunc [%s] 0x%X\n",
                   kInterruptNames[cause], cause);
    }
}
```

## â° APIC å®šæ—¶å™¨ä¸­æ–­

### å®šæ—¶å™¨é…ç½®

```cpp
// å®šæ—¶å™¨é…ç½®å¸¸é‡
constexpr uint8_t kApicTimerVector = 0xF0;      // å®šæ—¶å™¨ä¸­æ–­å‘é‡
constexpr uint32_t kApicTimerFrequencyHz = 100; // 100Hz é¢‘ç‡

// åˆå§‹åŒ–å®šæ—¶å™¨
ApicSingleton::instance().SetupPeriodicTimer(
    kApicTimerFrequencyHz,
    kApicTimerVector
);
```

### å®šæ—¶å™¨ä¸­æ–­å¤„ç†

```cpp
uint64_t ApicTimerHandler(uint64_t cause, uint8_t *context) {
    static uint64_t tick_count = 0;
    tick_count++;

    // é™ä½æ—¥å¿—è¾“å‡ºé¢‘ç‡
    if (tick_count % 100 == 0) {
        klog::Info("APIC Timer interrupt %lu, vector 0x%X\n",
                   tick_count, cause);
    }

    // å‘é€EOIä¿¡å·ç¡®è®¤ä¸­æ–­å¤„ç†å®Œæˆ
    ApicSingleton::instance().SendEoi();
    return 0;
}
```

## âŒ¨ï¸ é”®ç›˜ä¸­æ–­å¤„ç†

### é”®ç›˜ä¸­æ–­é…ç½®

```cpp
constexpr uint8_t kKeyboardVector = 0xF1;  // é”®ç›˜ä¸­æ–­å‘é‡
constexpr uint8_t kKeyboardIrq = 1;        // é”®ç›˜ä½¿ç”¨IRQ1

bool EnableKeyboardInterrupt(uint8_t vector) {
    // è·å–å½“å‰CPUçš„APIC ID
    uint32_t destination_apic_id = cpu_io::GetCurrentCoreId();

    // é…ç½®IRQé‡å®šå‘
    return ApicSingleton::instance().SetIrqRedirection(
        kKeyboardIrq, vector, destination_apic_id, false
    );
}
```

### é”®ç›˜æ‰«æç å¤„ç†

```cpp
uint64_t KeyboardHandler(uint64_t cause, uint8_t *context) {
    // è¯»å–é”®ç›˜æ‰«æç  (ç«¯å£0x60)
    uint8_t scancode = cpu_io::In<uint8_t>(0x60);

    // å¤„ç†æŒ‰é”®æŒ‰ä¸‹äº‹ä»¶ (æœ€é«˜ä½ä¸º0)
    if (!(scancode & 0x80)) {
        klog::Info("Key pressed: scancode 0x%02X\n", scancode);

        // æ‰«æç åˆ°ASCIIè½¬æ¢
        static const char scancode_to_ascii[] = {
            0, 27, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
            '-', '=', '\b', '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i',
            'o', 'p', '[', ']', '\n', 0, 'a', 's', 'd', 'f', 'g', 'h',
            'j', 'k', 'l', ';', '\'', '`', 0, '\\', 'z', 'x', 'c', 'v',
            'b', 'n', 'm', ',', '.', '/', 0, '*', 0, ' '
        };

        if (scancode < sizeof(scancode_to_ascii) &&
            scancode_to_ascii[scancode]) {
            char ascii_char = scancode_to_ascii[scancode];
            klog::Info("Key: '%c'\n", ascii_char);
        }
    }

    // å‘é€EOIä¿¡å·
    ApicSingleton::instance().SendEoi();
    return 0;
}
```

## ğŸš€ ç³»ç»Ÿåˆå§‹åŒ–

### ä¸»å¤„ç†å™¨åˆå§‹åŒ– (BSP)

```cpp
void InterruptInit(int, const char **) {
    // 1. åˆå§‹åŒ–IDT
    InterruptSingleton::instance().SetUpIdtr();

    // 2. æ³¨å†ŒAPICå®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        kApicTimerVector, ApicTimerHandler
    );

    // 3. æ³¨å†Œé”®ç›˜ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        kKeyboardVector, KeyboardHandler
    );

    // 4. å¯ç”¨å¤–éƒ¨ä¸­æ–­
    cpu_io::EnableInterrupt();

    // 5. å¯åŠ¨å®šæ—¶å™¨
    ApicSingleton::instance().SetupPeriodicTimer(
        kApicTimerFrequencyHz, kApicTimerVector
    );

    // 6. å¯ç”¨é”®ç›˜ä¸­æ–­
    EnableKeyboardInterrupt(kKeyboardVector);

    klog::Info("x86_64 interrupt system initialized\n");
}
```

### ä»å¤„ç†å™¨åˆå§‹åŒ– (AP)

```cpp
void InterruptInitSMP(int, const char **) {
    // 1. æ¯ä¸ªæ ¸å¿ƒéƒ½éœ€è¦åˆå§‹åŒ–è‡ªå·±çš„IDT
    InterruptSingleton::instance().SetUpIdtr();

    // 2. å¯ç”¨ä¸­æ–­
    cpu_io::EnableInterrupt();

    klog::Info("x86_64 SMP interrupt initialization complete\n");
}
```

## ğŸ“Š æ€§èƒ½ç‰¹ç‚¹

### ä¼˜åŠ¿
- **æ¨¡æ¿é€’å½’åˆå§‹åŒ–**ï¼šç¼–è¯‘æ—¶ç”Ÿæˆæ‰€æœ‰IDTæ¡ç›®ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
- **ç±»å‹å®‰å…¨**ï¼šå¼ºç±»å‹çº¦æŸé˜²æ­¢ä¸­æ–­å‘é‡é”™è¯¯
- **APICé›†æˆ**ï¼šç°ä»£å¤šæ ¸å¤„ç†å™¨é«˜æ•ˆä¸­æ–­å¤„ç†
- **ç»Ÿä¸€æ¥å£**ï¼šInterruptBase æŠ½è±¡å±‚æ”¯æŒè·¨æ¶æ„å…¼å®¹

### è®¾è®¡è€ƒé‡
- **256ä¸ªä¸­æ–­å‘é‡**ï¼šå®Œæ•´è¦†ç›–x86_64ä¸­æ–­ç©ºé—´
- **æ¨¡æ¿å…ƒç¼–ç¨‹**ï¼šå‡å°‘ä»£ç é‡å¤ï¼Œæé«˜æ€§èƒ½
- **EOIå¤„ç†**ï¼šç¡®ä¿ä¸­æ–­æ§åˆ¶å™¨çŠ¶æ€æ­£ç¡®
- **IRQé‡å®šå‘**ï¼šæ”¯æŒå¤šæ ¸ä¸­æ–­è´Ÿè½½å‡è¡¡

---

# RISC-V 64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   RISC-V ä¸­æ–­å¤„ç†ç³»ç»Ÿ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  InterruptBase (æŠ½è±¡åŸºç±»)                                   â”‚
â”‚  â”œâ”€â”€ Do(cause, context)                                    â”‚
â”‚  â””â”€â”€ RegisterInterruptFunc(cause, func)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Interrupt (RISC-Vå®ç°)                                     â”‚
â”‚  â”œâ”€â”€ trap å¤„ç†ç¨‹åºå…¥å£                                      â”‚
â”‚  â”œâ”€â”€ å¼‚å¸¸/ä¸­æ–­åˆ†å‘æœºåˆ¶                                       â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„ç®¡ç†                                    â”‚
â”‚  â””â”€â”€ PLIC ä¸­æ–­æ§åˆ¶å™¨é›†æˆ                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PLIC (Platform-Level Interrupt Controller)                â”‚
â”‚  â”œâ”€â”€ å¤–éƒ¨ä¸­æ–­æºç®¡ç†                                         â”‚
â”‚  â”œâ”€â”€ ä¼˜å…ˆçº§ä»²è£æœºåˆ¶                                         â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­è·¯ç”±é…ç½®                                           â”‚
â”‚  â””â”€â”€ ä¸­æ–­å®Œæˆç¡®è®¤                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SBI å®šæ—¶å™¨é›†æˆ                                             â”‚
â”‚  â”œâ”€â”€ æœºå™¨æ¨¡å¼å®šæ—¶å™¨ä¸­æ–­                                      â”‚
â”‚  â”œâ”€â”€ ç›‘ç®¡æ¨¡å¼å®šæ—¶å™¨ä»£ç†                                      â”‚
â”‚  â””â”€â”€ æ—¶é—´ç‰‡è°ƒåº¦æ”¯æŒ                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è®¾å¤‡æ ‘(DT)ä¸­æ–­é…ç½®                                         â”‚
â”‚  â”œâ”€â”€ PLIC åŸºåœ°å€è§£æ                                       â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å·æ˜ å°„                                             â”‚
â”‚  â””â”€â”€ è®¾å¤‡ä¸­æ–­é…ç½®                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ CSR å¯„å­˜å™¨ç®¡ç†

### å…³é”®æ§åˆ¶çŠ¶æ€å¯„å­˜å™¨

```cpp
// ä¸­æ–­ä½¿èƒ½é…ç½®
void SetupInterrupts() {
    // ä½¿èƒ½ç›‘ç®¡æ¨¡å¼å¤–éƒ¨ä¸­æ–­ã€å®šæ—¶å™¨ä¸­æ–­å’Œè½¯ä»¶ä¸­æ–­
    cpu_io::SIE::SEIE::Set();  // å¤–éƒ¨ä¸­æ–­ä½¿èƒ½
    cpu_io::SIE::STIE::Set();  // å®šæ—¶å™¨ä¸­æ–­ä½¿èƒ½
    cpu_io::SIE::SSIE::Set();  // è½¯ä»¶ä¸­æ–­ä½¿èƒ½

    // è®¾ç½® trap å¤„ç†ç¨‹åºå…¥å£
    cpu_io::STVEC::Write(reinterpret_cast<uint64_t>(TrapEntry));

    // å…¨å±€ä¸­æ–­ä½¿èƒ½
    cpu_io::SSTATUS::SIE::Set();
}
```

### Trap å¤„ç†ç¨‹åºå…¥å£

```cpp
extern "C" void TrapEntry();  // æ±‡ç¼–å®ç°çš„trapå…¥å£

// trap åˆ†å‘å‡½æ•°
extern "C" uint64_t TrapHandler(uint64_t cause, uint64_t epc,
                               uint64_t context) {
    // æ£€æŸ¥æ˜¯å¦ä¸ºä¸­æ–­ï¼ˆæœ€é«˜ä½ä¸º1ï¼‰
    if (cause & (1ULL << 63)) {
        uint64_t interrupt_cause = cause & ~(1ULL << 63);
        return InterruptSingleton::instance().Do(
            interrupt_cause,
            reinterpret_cast<uint8_t*>(context)
        );
    } else {
        // å¤„ç†å¼‚å¸¸ï¼ˆæœ€é«˜ä½ä¸º0ï¼‰
        return HandleException(cause, epc, context);
    }
}
```

## ğŸ¯ ä¸­æ–­å¤„ç†æµç¨‹

### 1. ç¡¬ä»¶ä¸­æ–­æµç¨‹
```
å¤–éƒ¨è®¾å¤‡ â†’ PLIC â†’ Hart ä¸­æ–­çº¿ â†’ è¯»å– SCAUSE â†’ åˆ†å‘å¤„ç†
```

### 2. å®šæ—¶å™¨ä¸­æ–­æµç¨‹
```
SBIå®šæ—¶å™¨ â†’ Mæ¨¡å¼ä¸­æ–­ â†’ ä»£ç†åˆ°Sæ¨¡å¼ â†’ SCAUSE[5] â†’ å¤„ç†å‡½æ•°
```

### 3. ä¸­æ–­åˆ†å‘æœºåˆ¶

```cpp
class Interrupt : public InterruptBase {
    static constexpr size_t kInterruptMaxCount = 64;
    static std::array<InterruptFunc, kInterruptMaxCount> interrupt_handlers;

public:
    uint64_t Do(uint64_t cause, uint8_t *context) override {
        if (cause < kInterruptMaxCount && interrupt_handlers[cause]) {
            return interrupt_handlers[cause](cause, context);
        }

        klog::Warn("Unhandled interrupt: cause=%lu\n", cause);
        return 0;
    }
};
```

## ğŸ›ï¸ PLIC ä¸­æ–­æ§åˆ¶å™¨

### PLIC åˆå§‹åŒ–é…ç½®

```cpp
void SetupPlic() {
    auto plic_base = GetPlicBaseFromDT();  // ä»è®¾å¤‡æ ‘è·å–åŸºåœ°å€

    // 1. è®¾ç½®æ‰€æœ‰ä¸­æ–­æºä¼˜å…ˆçº§ï¼ˆéé›¶å€¼å¯ç”¨ï¼‰
    for (uint32_t irq = 1; irq <= kMaxInterruptSources; irq++) {
        WritePlicReg(plic_base, PLIC_PRIORITY_BASE + irq * 4, 1);
    }

    // 2. ä¸ºå½“å‰hartå¯ç”¨æ‰€æœ‰ä¸­æ–­æº
    uint32_t hart_id = cpu_io::GetCurrentCoreId();
    uint64_t enable_reg = plic_base + PLIC_ENABLE_BASE +
                         hart_id * PLIC_ENABLE_STRIDE;

    // å¯ç”¨ä¸­æ–­æº 1-63 (æ¯ä¸ªbitä»£è¡¨ä¸€ä¸ªä¸­æ–­æº)
    WritePlicReg(enable_reg, 0x0, 0xFFFFFFFE);  // bits 1-31
    WritePlicReg(enable_reg, 0x4, 0xFFFFFFFF);  // bits 32-63

    // 3. è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§é˜ˆå€¼ï¼ˆ0è¡¨ç¤ºæ¥å—æ‰€æœ‰ä¼˜å…ˆçº§ï¼‰
    uint64_t threshold_reg = plic_base + PLIC_THRESHOLD_BASE +
                            hart_id * PLIC_THRESHOLD_STRIDE;
    WritePlicReg(threshold_reg, 0x0, 0);
}
```

### PLIC ä¸­æ–­å¤„ç†

```cpp
uint64_t PlicInterruptHandler(uint64_t cause, uint8_t *context) {
    uint32_t hart_id = cpu_io::GetCurrentCoreId();
    uint64_t plic_base = GetPlicBaseFromDT();

    // 1. å£°æ˜(claim)ä¸­æ–­ - è·å–æœ€é«˜ä¼˜å…ˆçº§çš„å¾…å¤„ç†ä¸­æ–­
    uint64_t claim_reg = plic_base + PLIC_CLAIM_BASE +
                        hart_id * PLIC_CLAIM_STRIDE;
    uint32_t irq = ReadPlicReg(claim_reg, 0x0);

    if (irq == 0) {
        klog::Warn("Spurious PLIC interrupt\n");
        return 0;
    }

    klog::Debug("PLIC interrupt: IRQ %u\n", irq);

    // 2. è°ƒç”¨ç‰¹å®šè®¾å¤‡çš„ä¸­æ–­å¤„ç†ç¨‹åº
    auto device_handler = GetDeviceHandler(irq);
    if (device_handler) {
        device_handler(irq, context);
    }

    // 3. å®Œæˆ(complete)ä¸­æ–­ - é€šçŸ¥PLICä¸­æ–­å¤„ç†å®Œæˆ
    WritePlicReg(claim_reg, 0x0, irq);

    return 0;
}
```

## â° SBI å®šæ—¶å™¨ä¸­æ–­

### å®šæ—¶å™¨é…ç½®

```cpp
constexpr uint64_t kTimerIntervalCycles = 10000000;  // 10M cycles â‰ˆ 100Hz

void SetupTimer() {
    // è®¾ç½®ä¸‹ä¸€æ¬¡å®šæ—¶å™¨ä¸­æ–­æ—¶é—´
    uint64_t current_time = cpu_io::Time::Read();
    sbi::SetTimer(current_time + kTimerIntervalCycles);

    // æ³¨å†Œå®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•° (ç›‘ç®¡æ¨¡å¼å®šæ—¶å™¨ä¸­æ–­ = 5)
    InterruptSingleton::instance().RegisterInterruptFunc(
        5, TimerInterruptHandler
    );
}
```

### å®šæ—¶å™¨ä¸­æ–­å¤„ç†

```cpp
uint64_t TimerInterruptHandler(uint64_t cause, uint8_t *context) {
    static uint64_t tick_count = 0;
    tick_count++;

    // è®¾ç½®ä¸‹ä¸€æ¬¡å®šæ—¶å™¨ä¸­æ–­
    uint64_t current_time = cpu_io::Time::Read();
    sbi::SetTimer(current_time + kTimerIntervalCycles);

    // é™ä½æ—¥å¿—è¾“å‡ºé¢‘ç‡
    if (tick_count % 100 == 0) {
        klog::Info("Timer interrupt %lu, cause %lu\n", tick_count, cause);
    }

    return 0;
}
```

## ğŸ”Œ UART ä¸­æ–­å¤„ç†

### UART ä¸­æ–­é…ç½®

```cpp
void SetupUartInterrupt() {
    // ä»è®¾å¤‡æ ‘è·å–UARTä¸­æ–­å·
    uint32_t uart_irq = GetUartIrqFromDT();

    // åœ¨PLICä¸­å¯ç”¨UARTä¸­æ–­
    EnablePlicInterrupt(uart_irq);

    // æ³¨å†ŒUARTä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        uart_irq, UartInterruptHandler
    );

    // é…ç½®UARTç¡¬ä»¶å¯ç”¨ä¸­æ–­
    ConfigureUartInterrupts();
}
```

### UART ä¸­æ–­å¤„ç†

```cpp
uint64_t UartInterruptHandler(uint64_t cause, uint8_t *context) {
    // è¯»å–UARTä¸­æ–­çŠ¶æ€
    auto uart_base = GetUartBaseFromDT();
    uint32_t interrupt_status = ReadUartReg(uart_base, UART_IIR_OFFSET);

    // å¤„ç†æ¥æ”¶ä¸­æ–­
    if (interrupt_status & UART_IIR_RDI) {
        while (ReadUartReg(uart_base, UART_LSR_OFFSET) & UART_LSR_DR) {
            char received_char = ReadUartReg(uart_base, UART_RBR_OFFSET);
            klog::Info("UART received: '%c' (0x%02X)\n",
                      received_char, received_char);

            // å›æ˜¾å­—ç¬¦
            WriteUartReg(uart_base, UART_THR_OFFSET, received_char);
        }
    }

    return 0;
}
```

## ğŸš€ ç³»ç»Ÿåˆå§‹åŒ–

### ä¸»hartåˆå§‹åŒ–

```cpp
void InterruptInit(int, const char **) {
    // 1. è§£æè®¾å¤‡æ ‘è·å–ä¸­æ–­é…ç½®
    auto kernel_fdt = KernelFdtSingleton::instance();

    // 2. è®¾ç½®trapå‘é‡
    cpu_io::STVEC::Write(reinterpret_cast<uint64_t>(TrapEntry));

    // 3. åˆå§‹åŒ–PLIC
    SetupPlic();

    // 4. æ³¨å†Œå®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        5, TimerInterruptHandler  // ç›‘ç®¡æ¨¡å¼å®šæ—¶å™¨ä¸­æ–­
    );

    // 5. æ³¨å†Œå¤–éƒ¨ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        9, PlicInterruptHandler   // ç›‘ç®¡æ¨¡å¼å¤–éƒ¨ä¸­æ–­
    );

    // 6. å¯ç”¨ä¸­æ–­
    cpu_io::SIE::SEIE::Set();   // å¤–éƒ¨ä¸­æ–­
    cpu_io::SIE::STIE::Set();   // å®šæ—¶å™¨ä¸­æ–­
    cpu_io::SSTATUS::SIE::Set(); // å…¨å±€ä¸­æ–­ä½¿èƒ½

    // 7. å¯åŠ¨å®šæ—¶å™¨
    SetupTimer();

    // 8. å¯åŠ¨å…¶ä»–hart
    StartSecondaryHarts();

    klog::Info("RISC-V interrupt system initialized\n");
}
```

### ä»hartåˆå§‹åŒ–

```cpp
void InterruptInitSMP(int, const char **) {
    // 1. è®¾ç½®trapå‘é‡
    cpu_io::STVEC::Write(reinterpret_cast<uint64_t>(TrapEntry));

    // 2. å¯ç”¨ä¸­æ–­
    cpu_io::SIE::SEIE::Set();
    cpu_io::SIE::STIE::Set();
    cpu_io::SSTATUS::SIE::Set();

    // 3. å¯åŠ¨å®šæ—¶å™¨
    SetupTimer();

    klog::Info("RISC-V SMP hart %lu initialized\n",
               cpu_io::GetCurrentCoreId());
}
```

## ğŸ“Š æ€§èƒ½ç‰¹ç‚¹

### ä¼˜åŠ¿
- **PLICä¼˜å…ˆçº§ä»²è£**ï¼šç¡¬ä»¶çº§ä¸­æ–­ä¼˜å…ˆçº§ç®¡ç†
- **SBIå®šæ—¶å™¨**ï¼šé«˜ç²¾åº¦å®šæ—¶å™¨æœåŠ¡
- **è®¾å¤‡æ ‘é…ç½®**ï¼šåŠ¨æ€ç¡¬ä»¶é…ç½®å‘ç°
- **å¤šhartæ”¯æŒ**ï¼šåŸç”Ÿå¤šæ ¸ä¸­æ–­å¤„ç†

### è®¾è®¡è€ƒé‡
- **CSRç›´æ¥è®¿é—®**ï¼šé¿å…ç‰¹æƒçº§åˆ‡æ¢å¼€é”€
- **PLICå£°æ˜/å®Œæˆæœºåˆ¶**ï¼šç¡®ä¿ä¸­æ–­ä¸ä¸¢å¤±
- **OpenSBIé›†æˆ**ï¼šåˆ©ç”¨å›ºä»¶æœåŠ¡
- **trapç»Ÿä¸€å…¥å£**ï¼šç®€åŒ–å¼‚å¸¸å’Œä¸­æ–­å¤„ç†

---

# AArch64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   AArch64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  InterruptBase (æŠ½è±¡åŸºç±»)                                   â”‚
â”‚  â”œâ”€â”€ Do(cause, context)                                    â”‚
â”‚  â””â”€â”€ RegisterInterruptFunc(cause, func)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Interrupt (AArch64å®ç°)                                    â”‚
â”‚  â”œâ”€â”€ å¼‚å¸¸å‘é‡è¡¨(Vector Table)                              â”‚
â”‚  â”œâ”€â”€ å¼‚å¸¸çº§åˆ«ç®¡ç† (EL0-EL3)                                â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„ç®¡ç†                                    â”‚
â”‚  â””â”€â”€ GIC ä¸­æ–­æ§åˆ¶å™¨é›†æˆ                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  GIC (Generic Interrupt Controller)                        â”‚
â”‚  â”œâ”€â”€ SGI (Software Generated Interrupts)                  â”‚
â”‚  â”œâ”€â”€ PPI (Private Peripheral Interrupts)                  â”‚
â”‚  â”œâ”€â”€ SPI (Shared Peripheral Interrupts)                   â”‚
â”‚  â””â”€â”€ ä¸­æ–­ä¼˜å…ˆçº§å’Œè·¯ç”±ç®¡ç†                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Generic Timer                                             â”‚
â”‚  â”œâ”€â”€ è™šæ‹Ÿå®šæ—¶å™¨ (EL1 Virtual Timer)                        â”‚
â”‚  â”œâ”€â”€ ç‰©ç†å®šæ—¶å™¨ (EL1 Physical Timer)                       â”‚
â”‚  â”œâ”€â”€ é«˜åˆ†è¾¨ç‡æ—¶é—´è®¡æ•°                                        â”‚
â”‚  â””â”€â”€ å®šæ—¶å™¨ä¸­æ–­ç”Ÿæˆ                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è®¾å¤‡æ ‘(DT)ä¸­æ–­é…ç½®                                         â”‚
â”‚  â”œâ”€â”€ GIC åŸºåœ°å€è§£æ                                        â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å·æ˜ å°„å…³ç³»                                         â”‚
â”‚  â”œâ”€â”€ è®¾å¤‡ä¸­æ–­é…ç½®                                           â”‚
â”‚  â””â”€â”€ PSCI å¤šæ ¸å¯åŠ¨ç®¡ç†                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ å¼‚å¸¸å‘é‡è¡¨ç®¡ç†

### å¼‚å¸¸å‘é‡è¡¨ç»“æ„

```cpp
// å¼‚å¸¸å‘é‡è¡¨å…¥å£å®šä¹‰
extern "C" void vector_table();  // æ±‡ç¼–å®ç°çš„å‘é‡è¡¨

// å‘é‡è¡¨åŒ…å«16ä¸ªå…¥å£ï¼Œæ¯ä¸ªå…¥å£128å­—èŠ‚
struct ExceptionVectors {
    // Current EL with SP0
    void curr_el_sp0_sync();     // åŒæ­¥å¼‚å¸¸
    void curr_el_sp0_irq();      // IRQä¸­æ–­
    void curr_el_sp0_fiq();      // FIQä¸­æ–­
    void curr_el_sp0_serror();   // SErrorå¼‚å¸¸

    // Current EL with SPx
    void curr_el_spx_sync();
    void curr_el_spx_irq();
    void curr_el_spx_fiq();
    void curr_el_spx_serror();

    // Lower EL using AArch64
    void lower_el_aarch64_sync();
    void lower_el_aarch64_irq();
    void lower_el_aarch64_fiq();
    void lower_el_aarch64_serror();

    // Lower EL using AArch32
    void lower_el_aarch32_sync();
    void lower_el_aarch32_irq();
    void lower_el_aarch32_fiq();
    void lower_el_aarch32_serror();
};
```

### å¼‚å¸¸å¤„ç†å™¨å®ç°

```cpp
// C++å¼‚å¸¸å¤„ç†å‡½æ•°
extern "C" void sync_exception_handler(uint64_t esr, uint64_t elr,
                                       uint64_t context) {
    uint32_t ec = (esr >> 26) & 0x3F;  // Exception Class
    uint32_t iss = esr & 0xFFFFFF;     // Instruction Specific Syndrome

    klog::Error("Sync exception: EC=0x%X, ISS=0x%X, ELR=0x%lX\n",
                ec, iss, elr);

    // æ ¹æ®å¼‚å¸¸ç±»å‹è¿›è¡Œå¤„ç†
    switch (ec) {
        case 0x15:  // SVC instruction execution in AArch64 state
            HandleSvc(iss, context);
            break;
        case 0x21:  // Instruction abort from lower EL
            HandleInstructionAbort(iss, elr);
            break;
        case 0x25:  // Data abort from lower EL
            HandleDataAbort(iss, elr);
            break;
        default:
            klog::Error("Unhandled sync exception\n");
            break;
    }
}

extern "C" void irq_exception_handler(uint64_t context) {
    // è¯»å–ä¸­æ–­ç¡®è®¤å¯„å­˜å™¨è·å–ä¸­æ–­ID
    uint32_t intid = GicSingleton::instance().GetInterruptId();

    if (intid == 1023) {  // Spurious interrupt
        klog::Warn("Spurious interrupt\n");
        return;
    }

    // è°ƒç”¨æ³¨å†Œçš„ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().Do(intid,
        reinterpret_cast<uint8_t*>(context));

    // å‘é€End of Interruptä¿¡å·
    GicSingleton::instance().EndOfInterrupt(intid);
}
```

## ğŸ¯ ä¸­æ–­å¤„ç†æµç¨‹

### 1. ç¡¬ä»¶ä¸­æ–­æµç¨‹
```
å¤–éƒ¨è®¾å¤‡ â†’ GICåˆ†å‘å™¨ â†’ CPUæ¥å£ â†’ å¼‚å¸¸å‘é‡è¡¨ â†’ IRQå¤„ç†å™¨
```

### 2. ä¸­æ–­IDè·å–å’Œå¤„ç†
```cpp
class Interrupt : public InterruptBase {
    static constexpr size_t kInterruptMaxCount = 1024;  // GICæ”¯æŒ1024ä¸ªä¸­æ–­
    static std::array<InterruptFunc, kInterruptMaxCount> interrupt_handlers;

public:
    uint64_t Do(uint64_t cause, uint8_t *context) override {
        if (cause < kInterruptMaxCount && interrupt_handlers[cause]) {
            return interrupt_handlers[cause](cause, context);
        }

        klog::Warn("Unhandled interrupt: INTID=%lu\n", cause);
        return 0;
    }

    // è®¾ç½®ä¸­æ–­ä¸ºSPIç±»å‹
    void SPI(uint32_t intid, uint32_t cpu_id) {
        GicSingleton::instance().SetInterruptType(intid,
            Gic::InterruptType::SPI);
        GicSingleton::instance().SetTargetCpu(intid, cpu_id);
        GicSingleton::instance().EnableInterrupt(intid);
    }

    // è®¾ç½®ä¸­æ–­ä¸ºPPIç±»å‹
    void PPI(uint32_t intid, uint32_t cpu_id) {
        GicSingleton::instance().SetInterruptType(intid,
            Gic::InterruptType::PPI);
        GicSingleton::instance().EnableInterrupt(intid);
    }
};
```

## ğŸ›ï¸ GIC ä¸­æ–­æ§åˆ¶å™¨

### GIC åˆå§‹åŒ–é…ç½®

```cpp
class Gic {
public:
    static constexpr uint32_t kSGIBase = 0;      // SGI: 0-15
    static constexpr uint32_t kPPIBase = 16;     // PPI: 16-31
    static constexpr uint32_t kSPIBase = 32;     // SPI: 32-1019

    void SetUP() {
        auto gic_base = GetGicBaseFromDT();  // ä»è®¾å¤‡æ ‘è·å–åŸºåœ°å€

        // 1. åˆå§‹åŒ–åˆ†å‘å™¨(Distributor)
        InitDistributor(gic_base);

        // 2. åˆå§‹åŒ–CPUæ¥å£
        InitCpuInterface(gic_base);

        // 3. å¯ç”¨åˆ†å‘å™¨
        EnableDistributor();
    }

private:
    void InitDistributor(uint64_t dist_base) {
        // ç¦ç”¨åˆ†å‘å™¨è¿›è¡Œé…ç½®
        WriteReg(dist_base + GICD_CTLR, 0);

        // é…ç½®æ‰€æœ‰SPIä¸ºè¾¹æ²¿è§¦å‘ï¼Œé«˜ä¼˜å…ˆçº§
        for (uint32_t i = kSPIBase; i < 1020; i += 32) {
            WriteReg(dist_base + GICD_ICFGR + (i/16)*4, 0x55555555);
        }

        // è®¾ç½®æ‰€æœ‰ä¸­æ–­ä¼˜å…ˆçº§
        for (uint32_t i = 0; i < 1020; i += 4) {
            WriteReg(dist_base + GICD_IPRIORITYR + i, 0xA0A0A0A0);
        }

        // è®¾ç½®SPIç›®æ ‡CPUä¸ºCPU0
        for (uint32_t i = kSPIBase; i < 1020; i += 4) {
            WriteReg(dist_base + GICD_ITARGETSR + i, 0x01010101);
        }
    }

    void InitCpuInterface(uint64_t cpu_base) {
        // è®¾ç½®ä¼˜å…ˆçº§æ©ç (å…è®¸æ‰€æœ‰ä¼˜å…ˆçº§)
        WriteReg(cpu_base + GICC_PMR, 0xFF);

        // å¯ç”¨CPUæ¥å£
        WriteReg(cpu_base + GICC_CTLR, GICC_CTLR_ENABLE);
    }
};
```

### GIC ä¸­æ–­å¤„ç†

```cpp
uint32_t Gic::GetInterruptId() {
    uint64_t cpu_base = GetGicCpuBaseFromDT();

    // è¯»å–ä¸­æ–­ç¡®è®¤å¯„å­˜å™¨
    uint32_t iar = ReadReg(cpu_base + GICC_IAR);
    return iar & 0x3FF;  // INTIDåœ¨ä½10ä½
}

void Gic::EndOfInterrupt(uint32_t intid) {
    uint64_t cpu_base = GetGicCpuBaseFromDT();

    // å†™å…¥ä¸­æ–­ç»“æŸå¯„å­˜å™¨
    WriteReg(cpu_base + GICC_EOIR, intid);
}

void Gic::EnableInterrupt(uint32_t intid) {
    uint64_t dist_base = GetGicDistBaseFromDT();

    uint32_t reg_offset = (intid / 32) * 4;
    uint32_t bit_offset = intid % 32;

    // è®¾ç½®ä½¿èƒ½ä½
    WriteReg(dist_base + GICD_ISENABLER + reg_offset,
             1U << bit_offset);
}
```

## â° Generic Timer ä¸­æ–­

### å®šæ—¶å™¨é…ç½®

```cpp
void SetupTimer() {
    // ä»è®¾å¤‡æ ‘è·å–å®šæ—¶å™¨ä¸­æ–­ID
    auto timer_intid = KernelFdtSingleton::instance()
        .GetAarch64Intid("arm,armv8-timer") + Gic::kPPIBase;

    // é…ç½®ä¸ºPPIç±»å‹ä¸­æ–­
    InterruptSingleton::instance().PPI(timer_intid,
        cpu_io::GetCurrentCoreId());

    // æ³¨å†Œå®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        timer_intid, timer_handler);

    // é…ç½®è™šæ‹Ÿå®šæ—¶å™¨
    cpu_io::CNTV_CTL_EL0::ENABLE::Clear();  // å…ˆç¦ç”¨
    cpu_io::CNTV_CTL_EL0::IMASK::Set();     // å±è”½ä¸­æ–­

    // è®¾ç½®å®šæ—¶å™¨é—´éš” (2ç§’)
    uint64_t interval_clk = 2 * cpu_io::CNTFRQ_EL0::Read();
    cpu_io::CNTV_TVAL_EL0::Write(interval_clk);

    // å¯ç”¨å®šæ—¶å™¨å’Œä¸­æ–­
    cpu_io::CNTV_CTL_EL0::ENABLE::Set();    // å¯ç”¨å®šæ—¶å™¨
    cpu_io::CNTV_CTL_EL0::IMASK::Clear();   // å–æ¶ˆä¸­æ–­å±è”½
}
```

### å®šæ—¶å™¨ä¸­æ–­å¤„ç†

```cpp
uint64_t timer_handler(uint64_t cause, uint8_t *context) {
    static uint64_t tick_count = 0;
    tick_count++;

    // é‡æ–°è®¾ç½®ä¸‹ä¸€æ¬¡å®šæ—¶å™¨ä¸­æ–­
    uint64_t interval_clk = 2 * cpu_io::CNTFRQ_EL0::Read();
    cpu_io::CNTV_TVAL_EL0::Write(interval_clk);

    // é™ä½æ—¥å¿—è¾“å‡ºé¢‘ç‡
    if (tick_count % 10 == 0) {
        klog::Info("Timer interrupt %lu, INTID %lu\n", tick_count, cause);
    }

    return 0;
}
```

## ğŸ”Œ UART ä¸­æ–­å¤„ç†

### UART ä¸­æ–­é…ç½®

```cpp
void SetupUartInterrupt() {
    // ä»è®¾å¤‡æ ‘è·å–UARTä¸­æ–­ID
    auto uart_intid = KernelFdtSingleton::instance()
        .GetAarch64Intid("arm,pl011") + Gic::kSPIBase;

    // é…ç½®ä¸ºSPIç±»å‹ä¸­æ–­ï¼Œè·¯ç”±åˆ°å½“å‰CPU
    InterruptSingleton::instance().SPI(uart_intid,
        cpu_io::GetCurrentCoreId());

    // æ³¨å†ŒUARTä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        uart_intid, uart_handler);
}
```

### UART ä¸­æ–­å¤„ç†

```cpp
uint64_t uart_handler(uint64_t cause, uint8_t *context) {
    auto uart_base = GetUartBaseFromDT();

    // è¯»å–ä¸­æ–­çŠ¶æ€
    uint32_t mis = ReadReg(uart_base + PL011_MIS);

    // å¤„ç†æ¥æ”¶ä¸­æ–­
    if (mis & PL011_MIS_RXMIS) {
        while (!(ReadReg(uart_base + PL011_FR) & PL011_FR_RXFE)) {
            char received_char = ReadReg(uart_base + PL011_DR) & 0xFF;
            klog::Info("UART received: '%c' (0x%02X)\n",
                      received_char, received_char);

            // å›æ˜¾å­—ç¬¦
            WriteReg(uart_base + PL011_DR, received_char);
        }

        // æ¸…é™¤æ¥æ”¶ä¸­æ–­
        WriteReg(uart_base + PL011_ICR, PL011_ICR_RXIC);
    }

    // å¤„ç†å‘é€ä¸­æ–­
    if (mis & PL011_MIS_TXMIS) {
        // å‘é€ç¼“å†²åŒºç©ºï¼Œå¯ä»¥å‘é€æ›´å¤šæ•°æ®
        WriteReg(uart_base + PL011_ICR, PL011_ICR_TXIC);
    }

    return 0;
}
```

## ğŸš€ ç³»ç»Ÿåˆå§‹åŒ–

### ä¸»å¤„ç†å™¨åˆå§‹åŒ– (Primary CPU)

```cpp
void InterruptInit(int, const char **) {
    // 1. è®¾ç½®å¼‚å¸¸å‘é‡è¡¨åŸºåœ°å€
    cpu_io::VBAR_EL1::Write(reinterpret_cast<uint64_t>(vector_table));

    // 2. åˆå§‹åŒ–GIC
    InterruptSingleton::instance().SetUP();

    // 3. é…ç½®å®šæ—¶å™¨ä¸­æ–­
    auto timer_intid = KernelFdtSingleton::instance()
        .GetAarch64Intid("arm,armv8-timer") + Gic::kPPIBase;
    InterruptSingleton::instance().PPI(timer_intid,
        cpu_io::GetCurrentCoreId());
    InterruptSingleton::instance().RegisterInterruptFunc(
        timer_intid, timer_handler);

    // 4. é…ç½®UARTä¸­æ–­
    auto uart_intid = KernelFdtSingleton::instance()
        .GetAarch64Intid("arm,pl011") + Gic::kSPIBase;
    InterruptSingleton::instance().SPI(uart_intid,
        cpu_io::GetCurrentCoreId());
    InterruptSingleton::instance().RegisterInterruptFunc(
        uart_intid, uart_handler);

    // 5. å¯ç”¨ä¸­æ–­
    cpu_io::EnableInterrupt();

    // 6. å¯åŠ¨å®šæ—¶å™¨
    SetupTimer();

    // 7. å¯åŠ¨å…¶ä»–CPUæ ¸å¿ƒ
    StartSecondaryCpus();

    klog::Info("AArch64 interrupt system initialized\n");
}
```

### ä»å¤„ç†å™¨åˆå§‹åŒ– (Secondary CPUs)

```cpp
void InterruptInitSMP(int, const char **) {
    // 1. è®¾ç½®å¼‚å¸¸å‘é‡è¡¨
    cpu_io::VBAR_EL1::Write(reinterpret_cast<uint64_t>(vector_table));

    // 2. åˆå§‹åŒ–GIC CPUæ¥å£
    InterruptSingleton::instance().SetUP();

    // 3. é…ç½®å®šæ—¶å™¨ä¸­æ–­
    auto timer_intid = KernelFdtSingleton::instance()
        .GetAarch64Intid("arm,armv8-timer") + Gic::kPPIBase;
    InterruptSingleton::instance().PPI(timer_intid,
        cpu_io::GetCurrentCoreId());
    InterruptSingleton::instance().RegisterInterruptFunc(
        timer_intid, timer_handler);

    // 4. å¯ç”¨ä¸­æ–­
    cpu_io::EnableInterrupt();

    // 5. å¯åŠ¨å®šæ—¶å™¨
    SetupTimer();

    klog::Info("AArch64 SMP CPU %u initialized\n",
               cpu_io::GetCurrentCoreId());
}
```

### å¤šæ ¸å¯åŠ¨æµç¨‹

```cpp
void StartSecondaryCpus() {
    size_t core_count = BasicInfoSingleton::instance().core_count;

    for (size_t i = 1; i < core_count; i++) {  // è·³è¿‡CPU 0
        // ä½¿ç”¨PSCIå¯åŠ¨CPU
        auto ret = cpu_io::psci::CpuOn(i,
            reinterpret_cast<uint64_t>(_boot), 0);

        if ((ret != cpu_io::psci::SUCCESS) &&
            (ret != cpu_io::psci::ALREADY_ON)) {
            klog::Warn("CPU %d start failed: %d\n", i, ret);
        } else {
            klog::Info("CPU %d started successfully\n", i);
        }
    }
}
```

## ğŸ“Š æ€§èƒ½ç‰¹ç‚¹

### ä¼˜åŠ¿
- **å¼‚å¸¸çº§åˆ«éš”ç¦»**ï¼šEL0-EL3æä¾›å®Œæ•´çš„ç‰¹æƒçº§ä¿æŠ¤
- **GICç¡¬ä»¶ä¼˜å…ˆçº§**ï¼šé«˜æ•ˆçš„ä¸­æ–­ä»²è£å’Œè·¯ç”±
- **Generic Timer**ï¼šé«˜ç²¾åº¦ç³»ç»Ÿå®šæ—¶å™¨
- **PSCIæ ‡å‡†**ï¼šæ ‡å‡†åŒ–çš„å¤šæ ¸ç”µæºç®¡ç†

### è®¾è®¡è€ƒé‡
- **å‘é‡è¡¨å¯¹é½**ï¼š2KBå¯¹é½è¦æ±‚ç¡®ä¿æ€§èƒ½
- **ä¸­æ–­ç±»å‹åˆ†ç±»**ï¼šSGI/PPI/SPIæ»¡è¶³ä¸åŒåœºæ™¯éœ€æ±‚
- **è®¾å¤‡æ ‘é›†æˆ**ï¼šåŠ¨æ€ç¡¬ä»¶é…ç½®å‘ç°
- **ç¼–è¯‘å™¨é™åˆ¶**ï¼šæ‰‹åŠ¨å¼‚å¸¸å¤„ç†é¿å…å±æ€§é™åˆ¶

---

# ğŸ” å¤šæ¶æ„å¯¹æ¯”åˆ†æ

## ä¸­æ–­æ§åˆ¶å™¨å¯¹æ¯”

| ç‰¹æ€§ | x86_64 APIC | RISC-V PLIC | AArch64 GIC |
|------|-------------|-------------|-------------|
| ä¸­æ–­æ•°é‡ | 256ä¸ªå‘é‡ | å¯é…ç½®(é€šå¸¸1024) | 1024ä¸ªINTID |
| ä¼˜å…ˆçº§æ”¯æŒ | 16çº§(ç¡¬ä»¶) | å¯é…ç½®çº§åˆ« | 256çº§ |
| å¤šæ ¸æ”¯æŒ | Local+IO APIC | æ¯hartç‹¬ç«‹ | åˆ†å‘å™¨+CPUæ¥å£ |
| ä¸­æ–­ç±»å‹ | IRQ/NMI | å¤–éƒ¨ä¸­æ–­ | SGI/PPI/SPI |
| EOIæœºåˆ¶ | APIC EOIå¯„å­˜å™¨ | PLIC Complete | GIC EOIRå¯„å­˜å™¨ |

## å®šæ—¶å™¨æœºåˆ¶å¯¹æ¯”

| æ¶æ„ | å®šæ—¶å™¨ç±»å‹ | ç²¾åº¦ | ç¼–ç¨‹æ¥å£ |
|------|-----------|------|----------|
| x86_64 | APIC Timer | å¯ç¼–ç¨‹åˆ†é¢‘ | Local APICå¯„å­˜å™¨ |
| RISC-V | Machine Timer | å›ºå®šé¢‘ç‡ | SBIè°ƒç”¨ |
| AArch64 | Generic Timer | ç³»ç»Ÿé¢‘ç‡ | ç³»ç»Ÿå¯„å­˜å™¨ |

## åˆå§‹åŒ–å¤æ‚åº¦

1. **x86_64**: æ¨¡æ¿é€’å½’åˆå§‹åŒ–ï¼Œç¼–è¯‘æ—¶ä¼˜åŒ–
2. **RISC-V**: è®¾å¤‡æ ‘è§£æ + CSRé…ç½®
3. **AArch64**: å¼‚å¸¸å‘é‡è¡¨ + GICå¤šé˜¶æ®µåˆå§‹åŒ–

## æ€§èƒ½ç‰¹å¾

- **x86_64**: æ¨¡æ¿å…ƒç¼–ç¨‹ä¼˜åŒ–ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
- **RISC-V**: ç®€æ´çš„CSRæ¥å£ï¼ŒSBIæœåŠ¡é›†æˆ
- **AArch64**: ç¡¬ä»¶ä¼˜å…ˆçº§ä»²è£ï¼Œå¤šçº§å¼‚å¸¸å¤„ç†

è¿™ç§å¤šæ¶æ„è®¾è®¡ç¡®ä¿äº†SimpleKernelåœ¨ä¸åŒç¡¬ä»¶å¹³å°ä¸Šçš„é«˜æ•ˆè¿è¡Œï¼ŒåŒæ—¶ä¿æŒäº†ç»Ÿä¸€çš„ç¼–ç¨‹æ¥å£ã€‚
        kKeyboardVector, KeyboardHandler
    );

    // 4. å¯ç”¨é”®ç›˜ä¸­æ–­
    EnableKeyboardInterrupt(kKeyboardVector);

    // 5. å¯ç”¨APICå®šæ—¶å™¨
    ApicSingleton::instance().SetupPeriodicTimer(
        kApicTimerFrequencyHz, kApicTimerVector
    );

    // 6. å¼€å¯å…¨å±€ä¸­æ–­
    cpu_io::Rflags::If::Set();

    klog::Info("Hello InterruptInit\n");
}
```

### åº”ç”¨å¤„ç†å™¨åˆå§‹åŒ– (SMP)

```cpp
void InterruptInitSMP(int, const char **) {
    // 1. åˆå§‹åŒ–IDT (æ¯ä¸ªCPUéƒ½éœ€è¦)
    InterruptSingleton::instance().SetUpIdtr();

    // 2. å¯ç”¨APICå®šæ—¶å™¨
    ApicSingleton::instance().SetupPeriodicTimer(
        kApicTimerFrequencyHz, kApicTimerVector
    );

    // 3. å¼€å¯å…¨å±€ä¸­æ–­
    cpu_io::Rflags::If::Set();

    klog::Info("Hello InterruptInit SMP\n");
}
```

## ğŸ”§ é»˜è®¤å¼‚å¸¸å¤„ç†

ç³»ç»Ÿä¸ºæ‰€æœ‰æœªæ³¨å†Œçš„ä¸­æ–­/å¼‚å¸¸æä¾›é»˜è®¤å¤„ç†å™¨ï¼š

```cpp
Interrupt::Interrupt() {
    // ä¸ºæ‰€æœ‰ä¸­æ–­æ³¨å†Œé»˜è®¤å¤„ç†å‡½æ•°
    for (auto &i : interrupt_handlers) {
        i = [](uint64_t cause, uint8_t *context) -> uint64_t {
            klog::Info("Default Interrupt handler [%s] 0x%X, 0x%p\n",
                      kInterruptNames[cause], cause, context);
            DumpStack();  // æ‰“å°è°ƒç”¨æ ˆ
            while (true) { ; }  // åœæœº
        };
    }
    klog::Info("Interrupt init.\n");
}
```

## ğŸ“Š ä¸­æ–­ä¸Šä¸‹æ–‡ç»“æ„

### æ— é”™è¯¯ç ä¸­æ–­ä¸Šä¸‹æ–‡
```cpp
struct InterruptContext {
    uint64_t rip;     // æŒ‡ä»¤æŒ‡é’ˆ
    uint64_t cs;      // ä»£ç æ®µé€‰æ‹©å­
    uint64_t rflags;  // æ ‡å¿—å¯„å­˜å™¨
    uint64_t rsp;     // æ ˆæŒ‡é’ˆ
    uint64_t ss;      // æ ˆæ®µé€‰æ‹©å­
};
```

### æœ‰é”™è¯¯ç ä¸­æ–­ä¸Šä¸‹æ–‡
```cpp
struct InterruptContextErrorCode {
    uint32_t error_code;  // é”™è¯¯ç 
    uint32_t padding;     // å¡«å……å¯¹é½
    uint64_t rip;
    uint64_t cs;
    uint64_t rflags;
    uint64_t rsp;
    uint64_t ss;
};
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§

### 1. æ¨¡æ¿å…ƒç¼–ç¨‹
- **ç¼–è¯‘æ—¶å±•å¼€**: ä½¿ç”¨æ¨¡æ¿é€’å½’åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆæ‰€æœ‰IDTæ¡ç›®
- **é›¶è¿è¡Œæ—¶å¼€é”€**: é¿å…å¾ªç¯åˆå§‹åŒ–çš„è¿è¡Œæ—¶æˆæœ¬

### 2. å†…å­˜å¯¹é½ä¼˜åŒ–
```cpp
// 4KBå¯¹é½ä¼˜åŒ–ç¼“å­˜è¡Œä¸º
alignas(4096) static std::array<InterruptFunc, 256> interrupt_handlers;
alignas(4096) static std::array<Idt, 256> idts;
```

### 3. é«˜æ•ˆä¸­æ–­å±æ€§
```cpp
// ç¼–è¯‘å™¨ä¼˜åŒ–å±æ€§
__attribute__((target("general-regs-only")))  // åªä½¿ç”¨é€šç”¨å¯„å­˜å™¨
__attribute__((interrupt))                    // ä¸­æ–­å‡½æ•°ä¼˜åŒ–
```

## ğŸ”„ å¤šæ ¸å¤„ç† (SMP)

### BSP vs AP åˆå§‹åŒ–å·®å¼‚

| ç»„ä»¶ | BSP (ä¸»å¤„ç†å™¨) | AP (åº”ç”¨å¤„ç†å™¨) |
|------|---------------|----------------|
| IDTåˆå§‹åŒ– | âœ… | âœ… |
| ä¸­æ–­å¤„ç†å‡½æ•°æ³¨å†Œ | âœ… | âŒ (å…±äº«) |
| é”®ç›˜ä¸­æ–­é…ç½® | âœ… | âŒ |
| APICå®šæ—¶å™¨ | âœ… | âœ… |
| å…¨å±€ä¸­æ–­ä½¿èƒ½ | âœ… | âœ… |

### å¤šæ ¸ä¸­æ–­å®‰å…¨æ€§
- **æ¯æ ¸ç‹¬ç«‹IDT**: æ¯ä¸ªCPUæ ¸å¿ƒéƒ½æœ‰è‡ªå·±çš„IDTå‰¯æœ¬
- **å…±äº«ä¸­æ–­å¤„ç†å‡½æ•°**: ä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„åœ¨æ‰€æœ‰æ ¸å¿ƒé—´å…±äº«
- **APIC EOI**: æ¯ä¸ªæ ¸å¿ƒç‹¬ç«‹å‘é€EOIä¿¡å·

## ğŸ› è°ƒè¯•å’Œç›‘æ§

### ä¸­æ–­ä¿¡æ¯è¾“å‡º
```cpp
// è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡ºä¸­æ–­æ³¨å†Œä¿¡æ¯
klog::Debug("RegisterInterruptFunc [%s] 0x%X, 0x%p\n",
           kInterruptNames[cause], cause, func);

// IDTæ¡ç›®è°ƒè¯•ä¿¡æ¯
for (size_t i = 0; i < interrupt_count; i++) {
    klog::Debug("idtr[%d] 0x%p\n", i, idtr.base + i);
}
```

### é”™è¯¯å¤„ç†
- **æ ˆè½¬å‚¨**: æœªå¤„ç†å¼‚å¸¸æ—¶è‡ªåŠ¨æ‰“å°è°ƒç”¨æ ˆ
- **ç³»ç»Ÿåœæœº**: ä¸¥é‡é”™è¯¯æ—¶å®‰å…¨åœæœº
- **ä¸­æ–­åç§°æ˜ å°„**: é€šè¿‡åç§°æ•°ç»„æä¾›å¯è¯»çš„ä¸­æ–­ä¿¡æ¯

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [APIC é©±åŠ¨æ–‡æ¡£](../src/driver/apic/README.md)
- [CPU I/O åº“æ–‡æ¡£](../3rd/cpu_io/README.md)
- [å†…æ ¸æ—¥å¿—ç³»ç»Ÿ](../src/include/kernel_log.hpp)

## ğŸ”— å…³é”®æ•°æ®ç»“æ„

### ä¸­æ–­å‘é‡åˆ†é…
```cpp
0x00-0x1F: CPUå¼‚å¸¸ (é¡µé”™è¯¯ã€é™¤é›¶ç­‰)
0x20-0xEF: å¯ç”¨ç”¨æˆ·ä¸­æ–­å‘é‡
0xF0:      APICå®šæ—¶å™¨ä¸­æ–­
0xF1:      é”®ç›˜ä¸­æ–­
0xF2-0xFF: ä¿ç•™å‘é‡
```

### APIC é›†æˆç‚¹
- **Local APIC**: æ¯æ ¸å¿ƒå®šæ—¶å™¨å’ŒEOIå¤„ç†
- **IO APIC**: IRQé‡å®šå‘é…ç½®
- **x2APIC/xAPIC**: è‡ªåŠ¨æ£€æµ‹å’Œé…ç½®

---

# RISC-V 64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ

SimpleKernel åœ¨ RISC-V 64 æ¶æ„ä¸Šå®ç°äº†åŸºäº CSR (Control and Status Registers) å’Œ PLIC (Platform-Level Interrupt Controller) çš„å®Œæ•´ä¸­æ–­å¤„ç†ç³»ç»Ÿã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  RISC-V 64 ä¸­æ–­å¤„ç†ç³»ç»Ÿ                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  InterruptBase (æŠ½è±¡åŸºç±»)                                   â”‚
â”‚  â”œâ”€â”€ Do(cause, context)                                    â”‚
â”‚  â””â”€â”€ RegisterInterruptFunc(cause, func)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Interrupt (RISC-Vå®ç°)                                     â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­/å¼‚å¸¸åˆ†ç¦»å¤„ç†                                       â”‚
â”‚  â”œâ”€â”€ CSR scause è§£ç                                        â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„                                        â”‚
â”‚  â””â”€â”€ å¼‚å¸¸å¤„ç†å‡½æ•°æ•°ç»„                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PLIC (Platform-Level Interrupt Controller)                â”‚
â”‚  â”œâ”€â”€ å¤–éƒ¨ä¸­æ–­è·¯ç”±                                           â”‚
â”‚  â”œâ”€â”€ ä¸­æ–­ä¼˜å…ˆçº§ç®¡ç†                                         â”‚
â”‚  â”œâ”€â”€ å¤š Hart ä¸­æ–­åˆ†å‘                                       â”‚
â”‚  â””â”€â”€ ä¸­æ–­å®Œæˆç¡®è®¤                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  OpenSBI æ¥å£                                              â”‚
â”‚  â”œâ”€â”€ SBI å®šæ—¶å™¨æœåŠ¡                                         â”‚
â”‚  â”œâ”€â”€ Hart å¯åŠ¨ç®¡ç†                                          â”‚
â”‚  â”œâ”€â”€ ç³»ç»Ÿè°ƒç”¨æ¥å£                                           â”‚
â”‚  â””â”€â”€ è°ƒè¯•æ§åˆ¶å°                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è®¾å¤‡ç‰¹å®šä¸­æ–­                                               â”‚
â”‚  â”œâ”€â”€ å®šæ—¶å™¨ä¸­æ–­ (SBI Timer)                                 â”‚
â”‚  â”œâ”€â”€ ä¸²å£ä¸­æ–­ (NS16550A)                                    â”‚
â”‚  â”œâ”€â”€ å¤–éƒ¨ä¸­æ–­ (PLIC)                                        â”‚
â”‚  â””â”€â”€ æ–­ç‚¹å¼‚å¸¸ (ebreak)                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ CSR å¯„å­˜å™¨ç®¡ç†

### å…³é”® CSR å¯„å­˜å™¨

```cpp
// ä¸­æ–­/å¼‚å¸¸å¤„ç†ç›¸å…³çš„CSRå¯„å­˜å™¨
- stvec:   Supervisor Trap Vector Base Address (é™·é˜±å‘é‡åŸºå€)
- scause:  Supervisor Cause Register (é™·é˜±åŸå› )
- sstatus: Supervisor Status Register (ç›‘ç®¡è€…çŠ¶æ€)
- sie:     Supervisor Interrupt Enable (ç›‘ç®¡è€…ä¸­æ–­ä½¿èƒ½)
- sip:     Supervisor Interrupt Pending (ç›‘ç®¡è€…ä¸­æ–­æŒ‚èµ·)
- sepc:    Supervisor Exception Program Counter (å¼‚å¸¸PC)
- stval:   Supervisor Trap Value (é™·é˜±å€¼)
```

### scause å¯„å­˜å™¨è§£ç 

```cpp
void Interrupt::Do(uint64_t cause, uint8_t *context) {
    // è§£æ scause å¯„å­˜å™¨
    auto interrupt = cpu_io::Scause::Interrupt::Get(cause);     // æœ€é«˜ä½
    auto exception_code = cpu_io::Scause::ExceptionCode::Get(cause); // ä½ä½

    if (interrupt) {
        // å¤„ç†ä¸­æ–­ (å¼‚æ­¥äº‹ä»¶)
        if (exception_code < kInterruptMaxCount) {
            interrupt_handlers_[exception_code](exception_code, context);
        }
    } else {
        // å¤„ç†å¼‚å¸¸ (åŒæ­¥äº‹ä»¶)
        if (exception_code < kExceptionMaxCount) {
            exception_handlers_[exception_code](exception_code, context);
        }
    }
}
```

### é™·é˜±å…¥å£è®¾ç½®

```cpp
// è®¾ç½®é™·é˜±å‘é‡ - ç›´æ¥æ¨¡å¼
__attribute__((interrupt("supervisor")))
alignas(4) void TarpEntry() {
    InterruptSingleton::instance().Do(
        static_cast<uint64_t>(cpu_io::Scause::Read()), nullptr
    );
}

// åˆå§‹åŒ–æ—¶è®¾ç½®
cpu_io::Stvec::SetDirect(reinterpret_cast<uint64_t>(TarpEntry));
```

## ğŸ¯ ä¸­æ–­/å¼‚å¸¸åˆ†ç±»å¤„ç†

### ä¸­æ–­ç±»å‹ (scause[63] = 1)

```cpp
enum SupervisorInterrupts {
    kSupervisorSoftwareInterrupt = 1,    // Sæ¨¡å¼è½¯ä»¶ä¸­æ–­
    kSupervisorTimerInterrupt = 5,       // Sæ¨¡å¼å®šæ—¶å™¨ä¸­æ–­
    kSupervisorExternalInterrupt = 9,    // Sæ¨¡å¼å¤–éƒ¨ä¸­æ–­
};
```

### å¼‚å¸¸ç±»å‹ (scause[63] = 0)

```cpp
enum SupervisorExceptions {
    kInstructionAddressMisaligned = 0,   // æŒ‡ä»¤åœ°å€ä¸å¯¹é½
    kInstructionAccessFault = 1,         // æŒ‡ä»¤è®¿é—®é”™è¯¯
    kIllegalInstruction = 2,             // éæ³•æŒ‡ä»¤
    kBreakpoint = 3,                     // æ–­ç‚¹å¼‚å¸¸
    kLoadAddressMisaligned = 4,          // åŠ è½½åœ°å€ä¸å¯¹é½
    kLoadAccessFault = 5,                // åŠ è½½è®¿é—®é”™è¯¯
    kStoreAddressMisaligned = 6,         // å­˜å‚¨åœ°å€ä¸å¯¹é½
    kStoreAccessFault = 7,               // å­˜å‚¨è®¿é—®é”™è¯¯
    kEnvironmentCall = 8,                // ç¯å¢ƒè°ƒç”¨
    kInstructionPageFault = 12,          // æŒ‡ä»¤é¡µé”™è¯¯
    kLoadPageFault = 13,                 // åŠ è½½é¡µé”™è¯¯
    kStorePageFault = 15,                // å­˜å‚¨é¡µé”™è¯¯
};
```

## â° SBI å®šæ—¶å™¨ä¸­æ–­

### å®šæ—¶å™¨é…ç½®å’Œå¤„ç†

```cpp
namespace {
    uint64_t kInterval = 0;  // å®šæ—¶å™¨é—´éš”
}

void InterruptInit(int, const char **) {
    // ä»è®¾å¤‡æ ‘è·å–æ—¶é’Ÿé¢‘ç‡
    kInterval = KernelFdtSingleton::instance().GetTimebaseFrequency();
    klog::Info("kInterval: 0x%X\n", kInterval);

    // æ³¨å†Œå®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        kSupervisorTimerInterrupt,
        [](uint64_t exception_code, uint8_t *) -> uint64_t {
            // è®¾ç½®ä¸‹ä¸€æ¬¡å®šæ—¶å™¨ä¸­æ–­
            sbi_set_timer(cpu_io::Time::Read() + kInterval);
            klog::Info("Handle %s\n", kInterruptNames[exception_code]);
            return 0;
        }
    );

    // å¯ç”¨å®šæ—¶å™¨ä¸­æ–­
    cpu_io::Sie::Stie::Set();

    // è®¾ç½®é¦–æ¬¡å®šæ—¶å™¨ä¸­æ–­
    sbi_set_timer(kInterval);
}
```

### OpenSBI å®šæ—¶å™¨æ¥å£

```cpp
// è®¾ç½®å®šæ—¶å™¨ä¸­æ–­æ—¶é—´ (ç»å¯¹æ—¶é—´)
sbi_set_timer(cpu_io::Time::Read() + kInterval);

// è¯»å–å½“å‰æ—¶é—´
uint64_t current_time = cpu_io::Time::Read();
```

## ğŸ”Œ PLIC å¤–éƒ¨ä¸­æ–­æ§åˆ¶

### PLIC åˆå§‹åŒ–

```cpp
void InterruptInit(int, const char **) {
    // ä»è®¾å¤‡æ ‘è·å–PLICä¿¡æ¯
    auto [plic_addr, plic_size, ndev, context_count] =
        KernelFdtSingleton::instance().GetPlic();

    // åˆå§‹åŒ–PLICå®ä¾‹
    PlicSingleton::create(plic_addr, ndev, context_count);

    // æ³¨å†Œå¤–éƒ¨ä¸­æ–­å¤„ç†å‡½æ•°
    InterruptSingleton::instance().RegisterInterruptFunc(
        kSupervisorExternalInterrupt,
        [](uint64_t exception_code, uint8_t *) -> uint64_t {
            // æŸ¥è¯¢ä¸­æ–­æº
            auto source_id = PlicSingleton::instance().Which();
            klog::Debug("External interrupt from source %d\n", source_id);

            // æ‰§è¡Œä¸­æ–­å¤„ç†
            PlicSingleton::instance().Do(source_id, nullptr);

            // å®Œæˆä¸­æ–­å¤„ç†
            PlicSingleton::instance().Done(source_id);
            return 0;
        }
    );

    // å¯ç”¨å¤–éƒ¨ä¸­æ–­
    cpu_io::Sie::Seie::Set();
}
```

### PLIC å¯„å­˜å™¨å¸ƒå±€

```cpp
class Plic {
private:
    static constexpr uint64_t kSourcePriorityOffset = 0x000000;  // ä¼˜å…ˆçº§
    static constexpr uint64_t kPendingBitsOffset = 0x001000;     // æŒ‚èµ·ä½
    static constexpr uint64_t kEnableBitsOffset = 0x002000;      // ä½¿èƒ½ä½
    static constexpr uint64_t kContextOffset = 0x200000;        // ä¸Šä¸‹æ–‡

    static constexpr uint64_t kContextSize = 0x1000;            // ä¸Šä¸‹æ–‡å¤§å°
    static constexpr uint64_t kPriorityThresholdOffset = 0x0;   // ä¼˜å…ˆçº§é˜ˆå€¼
    static constexpr uint64_t kClaimCompleteOffset = 0x4;       // å£°æ˜/å®Œæˆ
};
```

### PLIC ä¸­æ–­å¤„ç†æµç¨‹

```cpp
// 1. ä¸­æ–­è§¦å‘ â†’ PLIC è·¯ç”±åˆ°æŒ‡å®š Hart
// 2. Hart æ¥æ”¶å¤–éƒ¨ä¸­æ–­ â†’ æŸ¥è¯¢ä¸­æ–­æº
auto source_id = PlicSingleton::instance().Which();

// 3. æ‰§è¡Œè®¾å¤‡ç‰¹å®šçš„ä¸­æ–­å¤„ç†
PlicSingleton::instance().Do(source_id, nullptr);

// 4. é€šçŸ¥ PLIC ä¸­æ–­å¤„ç†å®Œæˆ
PlicSingleton::instance().Done(source_id);
```

## ğŸ“¡ ä¸²å£ä¸­æ–­å¤„ç†

### NS16550A ä¸²å£ä¸­æ–­

```cpp
void InterruptInit(int, const char **) {
    // ä»è®¾å¤‡æ ‘è·å–ä¸²å£ä¿¡æ¯
    auto [base, size, irq] = KernelFdtSingleton::instance().GetSerial();

    // åˆå§‹åŒ–ä¸²å£é©±åŠ¨
    Ns16550aSingleton::create(base);

    // æ³¨å†Œä¸²å£ä¸­æ–­å¤„ç†å‡½æ•°
    PlicSingleton::instance().RegisterInterruptFunc(
        irq,  // ä¸²å£IRQå·
        [](uint64_t, uint8_t *) -> uint64_t {
            // è¯»å–ä¸²å£å­—ç¬¦å¹¶å›æ˜¾
            sk_putchar(Ns16550aSingleton::instance().TryGetChar(), nullptr);
            return 0;
        }
    );

    // ä¸ºå½“å‰æ ¸å¿ƒå¯ç”¨ä¸²å£ä¸­æ–­
    PlicSingleton::instance().Set(
        cpu_io::GetCurrentCoreId(),  // Hart ID
        irq,                         // ä¸­æ–­æºID
        1,                          // ä¼˜å…ˆçº§
        true                        // å¯ç”¨
    );
}
```

## ğŸ›‘ å¼‚å¸¸å¤„ç†

### æ–­ç‚¹å¼‚å¸¸ (ebreak)

```cpp
// æ³¨å†Œæ–­ç‚¹å¼‚å¸¸å¤„ç†
InterruptSingleton::instance().RegisterInterruptFunc(
    kBreakpoint,
    [](uint64_t exception_code, uint8_t *) -> uint64_t {
        // ebreak æŒ‡ä»¤æ˜¯2å­—èŠ‚ï¼Œéœ€è¦è·³è¿‡
        cpu_io::Sepc::Write(cpu_io::Sepc::Read() + 2);
        klog::Info("Handle %s\n", kExceptionNames[exception_code]);
        return 0;
    }
);
```

### é»˜è®¤å¼‚å¸¸å¤„ç†

```cpp
Interrupt::Interrupt() {
    // é»˜è®¤å¼‚å¸¸å¤„ç† - ç³»ç»Ÿåœæœº
    for (auto &i : exception_handlers_) {
        i = [](uint64_t cause, uint8_t *context) -> uint64_t {
            klog::Err("Default Exception handler [%s] 0x%X, 0x%p\n",
                     kExceptionNames[cause], cause, context);
            while (1) ; // åœæœºç­‰å¾…
            return 0;
        };
    }
}
```

## ğŸš€ å¤šæ ¸ç³»ç»Ÿåˆå§‹åŒ–

### ä¸»æ ¸å¿ƒ (BSP) åˆå§‹åŒ–

```cpp
void InterruptInit(int, const char **) {
    // 1. è·å–ç³»ç»Ÿé…ç½®ä¿¡æ¯
    kInterval = KernelFdtSingleton::instance().GetTimebaseFrequency();

    // 2. æ³¨å†Œæ‰€æœ‰ä¸­æ–­/å¼‚å¸¸å¤„ç†å‡½æ•°
    RegisterTimerInterrupt();
    RegisterExternalInterrupt();
    RegisterSerialInterrupt();
    RegisterBreakpointException();

    // 3. åˆå§‹åŒ–ç¡¬ä»¶æ§åˆ¶å™¨
    InitializePlic();
    InitializeSerial();

    // 4. è®¾ç½®é™·é˜±å‘é‡å’Œå¯ç”¨ä¸­æ–­
    cpu_io::Stvec::SetDirect(reinterpret_cast<uint64_t>(TarpEntry));
    cpu_io::Sstatus::Sie::Set();  // å¯ç”¨ç›‘ç®¡è€…ä¸­æ–­
    cpu_io::Sie::Ssie::Set();     // å¯ç”¨è½¯ä»¶ä¸­æ–­
    cpu_io::Sie::Stie::Set();     // å¯ç”¨å®šæ—¶å™¨ä¸­æ–­
    cpu_io::Sie::Seie::Set();     // å¯ç”¨å¤–éƒ¨ä¸­æ–­

    // 5. å¯åŠ¨å®šæ—¶å™¨
    sbi_set_timer(kInterval);

    // 6. å¯åŠ¨å…¶ä»–æ ¸å¿ƒ
    for (size_t i = 0; i < core_count; i++) {
        auto ret = sbi_hart_start(i, reinterpret_cast<uint64_t>(_boot), 0);
        if (ret.error != SBI_SUCCESS && ret.error != SBI_ERR_ALREADY_AVAILABLE) {
            klog::Warn("hart %d start failed: %d\n", i, ret.error);
        }
    }
}
```

### åº”ç”¨æ ¸å¿ƒ (AP) åˆå§‹åŒ–

```cpp
void InterruptInitSMP(int, const char **) {
    // 1. è®¾ç½®é™·é˜±å‘é‡ (ä¸BSPç›¸åŒ)
    cpu_io::Stvec::SetDirect(reinterpret_cast<uint64_t>(TarpEntry));

    // 2. å¯ç”¨ä¸­æ–­ (ä¸BSPç›¸åŒ)
    cpu_io::Sstatus::Sie::Set();
    cpu_io::Sie::Ssie::Set();
    cpu_io::Sie::Stie::Set();
    cpu_io::Sie::Seie::Set();

    // 3. å¯åŠ¨å®šæ—¶å™¨ (ä½¿ç”¨å…¨å±€é—´éš”)
    sbi_set_timer(kInterval);

    klog::Info("Hello InterruptInitSMP\n");
}
```

## ğŸ”§ OpenSBI é›†æˆ

### SBI è°ƒç”¨æ¥å£

```cpp
// Hart ç®¡ç†
sbi_hart_start(hart_id, start_addr, priv);  // å¯åŠ¨æŒ‡å®šHart
sbi_hart_stop();                            // åœæ­¢å½“å‰Hart
sbi_hart_get_status(hart_id);              // è·å–HartçŠ¶æ€

// å®šæ—¶å™¨æœåŠ¡
sbi_set_timer(stime_value);                // è®¾ç½®å®šæ—¶å™¨
uint64_t time = cpu_io::Time::Read();      // è¯»å–å½“å‰æ—¶é—´

// è°ƒè¯•æœåŠ¡
sbi_debug_console_write_byte(ch);          // è°ƒè¯•æ§åˆ¶å°è¾“å‡º

// ç³»ç»Ÿé‡ç½®
sbi_system_reset(reset_type, reset_reason); // ç³»ç»Ÿé‡ç½®
```

### SBI é”™è¯¯å¤„ç†

```cpp
auto ret = sbi_hart_start(i, start_addr, 0);
switch (ret.error) {
    case SBI_SUCCESS:
        klog::Info("Hart %zu started successfully\n", i);
        break;
    case SBI_ERR_ALREADY_AVAILABLE:
        klog::Debug("Hart %zu already running\n", i);
        break;
    default:
        klog::Warn("Hart %zu start failed: %ld\n", i, ret.error);
        break;
}
```

## ğŸ“Š è®¾å¤‡æ ‘ (Device Tree) é›†æˆ

### ä»è®¾å¤‡æ ‘è·å–ç¡¬ä»¶ä¿¡æ¯

```cpp
class KernelFdt {
public:
    // è·å–æ—¶é’Ÿé¢‘ç‡
    uint64_t GetTimebaseFrequency();

    // è·å–PLICä¿¡æ¯ <åœ°å€, å¤§å°, è®¾å¤‡æ•°, ä¸Šä¸‹æ–‡æ•°>
    std::tuple<uint64_t, uint64_t, size_t, size_t> GetPlic();

    // è·å–ä¸²å£ä¿¡æ¯ <åœ°å€, å¤§å°, IRQå·>
    std::tuple<uint64_t, uint64_t, uint32_t> GetSerial();
};

// ä½¿ç”¨ç¤ºä¾‹
auto [plic_addr, plic_size, ndev, context_count] =
    KernelFdtSingleton::instance().GetPlic();

auto [serial_base, serial_size, serial_irq] =
    KernelFdtSingleton::instance().GetSerial();
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§

### 1. å¯¹é½ä¼˜åŒ–

```cpp
// 4å­—èŠ‚å¯¹é½çš„ä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„
alignas(4) std::array<InterruptFunc, kInterruptMaxCount> interrupt_handlers_;
alignas(4) std::array<InterruptFunc, kExceptionMaxCount> exception_handlers_;

// 4å­—èŠ‚å¯¹é½çš„é™·é˜±å…¥å£
__attribute__((interrupt("supervisor"))) alignas(4) void TarpEntry();
```

### 2. åˆ†ç¦»çš„ä¸­æ–­/å¼‚å¸¸å¤„ç†

```cpp
// åˆ†ç¦»çš„å¤„ç†æ•°ç»„é¿å…æ— æ•ˆçš„èŒƒå›´æ£€æŸ¥
static std::array<InterruptFunc, kInterruptMaxCount> interrupt_handlers_;
static std::array<InterruptFunc, kExceptionMaxCount> exception_handlers_;
```

### 3. ç¡¬ä»¶ç‰¹å®šä¼˜åŒ–

```cpp
// åˆ©ç”¨RISC-V CSRæŒ‡ä»¤çš„åŸå­æ€§
auto cause = cpu_io::Scause::Read();  // åŸå­è¯»å–
cpu_io::Sepc::Write(pc + 2);         // åŸå­å†™å…¥
```

## ğŸ”„ å¤šæ ¸å¤„ç†ç‰¹æ€§

### BSP vs AP åˆå§‹åŒ–å·®å¼‚

| ç»„ä»¶ | BSP (ä¸»æ ¸å¿ƒ) | AP (åº”ç”¨æ ¸å¿ƒ) |
|------|-------------|--------------|
| è®¾å¤‡æ ‘è§£æ | âœ… | âŒ (å…±äº«) |
| ä¸­æ–­å¤„ç†å‡½æ•°æ³¨å†Œ | âœ… | âŒ (å…±äº«) |
| PLICåˆå§‹åŒ– | âœ… | âŒ (å…±äº«) |
| ä¸²å£é…ç½® | âœ… | âŒ (å…±äº«) |
| CSRé…ç½® | âœ… | âœ… |
| å®šæ—¶å™¨å¯åŠ¨ | âœ… | âœ… |
| å…¶ä»–æ ¸å¿ƒå¯åŠ¨ | âœ… | âŒ |

### å¤šæ ¸ä¸­æ–­å®‰å…¨æ€§

- **æ¯æ ¸ç‹¬ç«‹CSR**: æ¯ä¸ªHartæœ‰è‡ªå·±çš„CSRå‰¯æœ¬
- **å…±äº«PLIC**: æ‰€æœ‰Hartå…±äº«PLICï¼Œé€šè¿‡ä¸Šä¸‹æ–‡éš”ç¦»
- **å…±äº«å¤„ç†å‡½æ•°**: ä¸­æ–­å¤„ç†å‡½æ•°åœ¨æ‰€æœ‰æ ¸å¿ƒé—´å…±äº«
- **åŸå­æ“ä½œ**: CSRè®¿é—®å…·æœ‰ç¡¬ä»¶åŸå­æ€§ä¿è¯

## ğŸ› è°ƒè¯•å’Œç›‘æ§

### ä¸­æ–­ä¿¡æ¯è¾“å‡º

```cpp
// ä¸­æ–­æ³¨å†Œè°ƒè¯•ä¿¡æ¯
klog::Info("RegisterInterruptFunc [%s] 0x%X, 0x%p\n",
          kInterruptNames[exception_code], cause, func);

// PLICå¤–éƒ¨ä¸­æ–­è°ƒè¯•
klog::Debug("External interrupt from source %d\n", source_id);

// CSRçŠ¶æ€ç›‘æ§
klog::Debug("scause: 0x%lX, sepc: 0x%lX\n",
           cpu_io::Scause::Read(), cpu_io::Sepc::Read());
```

### å¼‚å¸¸è°ƒè¯•

```cpp
// å¼‚å¸¸å¤„ç†æ—¶çš„è¯¦ç»†ä¿¡æ¯è¾“å‡º
klog::Err("Exception [%s] at PC 0x%lX, tval: 0x%lX\n",
         kExceptionNames[cause],
         cpu_io::Sepc::Read(),
         cpu_io::Stval::Read());
```

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [OpenSBI æ¥å£æ–‡æ¡£](../3rd/opensbi_interface/README.md)
- [PLIC é©±åŠ¨æ–‡æ¡£](../src/driver/plic/README.md)
- [CPU I/O åº“æ–‡æ¡£](../3rd/cpu_io/README.md)
- [è®¾å¤‡æ ‘è§£æ](../src/include/kernel_fdt.hpp)

## ğŸ”— å…³é”®æ•°æ®ç»“æ„

### RISC-V ä¸­æ–­/å¼‚å¸¸ç¼–å·

```cpp
// ç›‘ç®¡è€…æ¨¡å¼ä¸­æ–­ (scause[63]=1)
#define S_SOFTWARE_INTERRUPT     1    // è½¯ä»¶ä¸­æ–­
#define S_TIMER_INTERRUPT        5    // å®šæ—¶å™¨ä¸­æ–­
#define S_EXTERNAL_INTERRUPT     9    // å¤–éƒ¨ä¸­æ–­

// ç›‘ç®¡è€…æ¨¡å¼å¼‚å¸¸ (scause[63]=0)
#define INSTRUCTION_MISALIGNED   0    // æŒ‡ä»¤ä¸å¯¹é½
#define INSTRUCTION_ACCESS_FAULT 1    // æŒ‡ä»¤è®¿é—®é”™è¯¯
#define ILLEGAL_INSTRUCTION      2    // éæ³•æŒ‡ä»¤
#define BREAKPOINT              3    // æ–­ç‚¹
#define LOAD_MISALIGNED         4    // åŠ è½½ä¸å¯¹é½
#define LOAD_ACCESS_FAULT       5    // åŠ è½½è®¿é—®é”™è¯¯
#define STORE_MISALIGNED        6    // å­˜å‚¨ä¸å¯¹é½
#define STORE_ACCESS_FAULT      7    // å­˜å‚¨è®¿é—®é”™è¯¯
#define ECALL_FROM_U_MODE       8    // ç”¨æˆ·æ¨¡å¼ç¯å¢ƒè°ƒç”¨
#define ECALL_FROM_S_MODE       9    // ç›‘ç®¡è€…æ¨¡å¼ç¯å¢ƒè°ƒç”¨
#define INSTRUCTION_PAGE_FAULT  12   // æŒ‡ä»¤é¡µé”™è¯¯
#define LOAD_PAGE_FAULT         13   // åŠ è½½é¡µé”™è¯¯
#define STORE_PAGE_FAULT        15   // å­˜å‚¨é¡µé”™è¯¯
```

### PLIC ä¸Šä¸‹æ–‡æ˜ å°„

```cpp
// PLIC ä¸Šä¸‹æ–‡è®¡ç®— (é€šå¸¸ä¸º 2 * hart_count)
Context 0: Hart 0 M-mode
Context 1: Hart 0 S-mode
Context 2: Hart 1 M-mode
Context 3: Hart 1 S-mode
...
```
